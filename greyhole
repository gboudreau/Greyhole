#!/usr/bin/php -d open_basedir=/
<?php
/*
Copyright 2009-2014 Guillaume Boudreau, Andrew Hopkinson

This file is part of Greyhole.

Greyhole is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Greyhole is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Greyhole.  If not, see <http://www.gnu.org/licenses/>.
*/

require_once('includes/common.php');
require_once('includes/CLI/CommandLineHelper.php'); // Command line helper (abstract classes, command line definitions & parsing, Runners, etc.)
require_once('includes/DaemonRunner.php');

// This will parse the command line, and find commands and options.
// It will then instantiate the appropriate class (that extends AbstractRunner), and return it.
$cliHelper = new CommandLineHelper();
$runner = $cliHelper->processCommandLine();

// This will run the runner(!) i.e. what the user asked for will now be executed.
$runner->run();

// The runner has finished; let's clean up before quitting.
$runner->finish();

function get_next_tasks($incl_md5=FALSE, $update_idle=TRUE) {
    global $locked_shares;
    $where_clause = "";
    if (!empty($locked_shares)) {
        $where_clause .= " AND share NOT IN ('" . implode("','", array_keys($locked_shares)) . "')";
    }
    if (!$incl_md5) {
        $where_clause .= " AND action != 'md5'";
    }

    $query = "SELECT id, action, share, full_path, additional_info, complete FROM tasks WHERE complete IN ('yes', 'thawed', 'written') $where_clause ORDER BY id ASC LIMIT 20";
    $tasks = DB::getAll($query);

    if (empty($tasks) && $update_idle) {
        // No more complete = yes|thawed; let's look for complete = 'idle' tasks.
        $query = "UPDATE tasks SET complete = 'yes' WHERE complete = 'idle'";
        DB::execute($query);
        $tasks = get_next_tasks($incl_md5, FALSE);
    }
    return $tasks;
}

function execute_next_task() {
    global $sleep_before_task, $next_task, $next_tasks, $current_task_id, $locked_files, $locked_shares, $written_files, $fix_symlinks_scanned_dirs;

    if (isset($next_task)) {
        $task = $next_task;
        unset($GLOBALS['next_task']);
    } else {
        $task = FALSE;
        if (!empty($next_tasks)) {
            $task = array_shift($next_tasks);
        }
        if ($task === FALSE) {
            $next_tasks = get_next_tasks(TRUE);
            if (!empty($next_tasks)) {
                $task = array_shift($next_tasks);
            } else {
                Log::setAction(ACTION_SLEEP);
                Log::debug("Nothing to do... Sleeping.");

                DB::repairTables();

                check_md5_workers();
                
                // Email any unsent fsck reports found in /usr/share/greyhole/
                foreach (array('fsck_checksums.log', 'fsck_files.log') as $log_file) {
                    $log = new FSCKLogFile($log_file);
                    $log->emailAsRequired();
                }

                $log_level = Log::getLevel();
                sleep($log_level == Log::DEBUG ? 10 : ($log_level == Log::TEST || $log_level == Log::PERF ? 1 : 600));
                $locked_files = array();
                $locked_shares = array();

                return;
            }
        }
    }
    $current_task_id = $task->id;

    # Postpone tasks in frozen directories until a --thaw command is received
    if ($task->complete != 'thawed') {
        $frozen_directories = Config::get(CONFIG_FROZEN_DIRECTORY);
        foreach ($frozen_directories as $frozen_directory) {
            if (string_starts_with("$task->share/$task->full_path", $frozen_directory)) {
                Log::setAction($task->action);
                Log::debug("Now working on task ID $task->id: $task->action " . clean_dir("$task->share/$task->full_path") . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : ''));
                Log::debug("  This directory is frozen. Will postpone this task until it is thawed.");
                postpone_task($task->id, 'frozen');
                archive_task($task->id);
                return;
            }
        }
    }
    
    if (array_contains($sleep_before_task, $task->id)) {
        Log::setAction(ACTION_SLEEP);
        Log::debug("Only locked files operations pending... Sleeping.");
        $log_level = Log::getLevel();
        sleep($log_level == Log::DEBUG ? 10 : ($log_level == Log::TEST ? 1 : 600));
        $sleep_before_task = array();
        $locked_files = array();
    }

    Log::setAction($task->action);
    Log::info("Now working on task ID $task->id: $task->action " . clean_dir("$task->share/$task->full_path") . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : ''));

    if ($task->complete == 'written') {
        if (should_ignore_file($task->share, $task->full_path)) {
            archive_task($task->id);
            return;
        }

        // Check if it's been 10 minutes since the file size changed. If so, process this normally.
        $filename = get_share_landing_zone($task->share) . '/' . $task->full_path;
        $filesize = gh_filesize($filename);
        if (empty($written_files[clean_dir("$task->share/$task->full_path")])) {
            $written_files[clean_dir("$task->share/$task->full_path")] = (object) array('since' => time(), 'filesize' => $filesize);
        } else {
            $infos = $written_files[clean_dir("$task->share/$task->full_path")];
            if ($infos->filesize == $filesize) {
                if (time() - $infos->since > 10*60) {
                    Log::debug("  File is still being written to (" . bytes_to_human($filesize, FALSE) . "). But it's been at least 10 minutes since the file size changed. We can probably assume we should work on this file now. Let do this!");
                    unset($written_files[clean_dir("$task->share/$task->full_path")]);
                }
            } else {
                $written_files[clean_dir("$task->share/$task->full_path")] = (object) array('since' => time(), 'filesize' => $filesize);
            }
        }

        if (!empty($written_files[clean_dir("$task->share/$task->full_path")])) {
            Log::debug("  File is still being written to (" . bytes_to_human($filesize, FALSE) . "). Postponing.");
            $locked_files[clean_dir("$task->share/$task->full_path")] = TRUE;
            $locked_shares[$task->share] = TRUE;
            return;
        }
    }

    if (!empty($locked_shares) && array_contains(array_keys($locked_shares), $task->share)) {
        Log::info("  Share is locked because another file operation is waiting for a file handle to be released. Skipping.");
        return;
    }

    switch ($task->action) {
        case 'balance':
            Log::info("Starting available space balancing");
            gh_balance();
            Log::info("Available space balancing completed.");
            break;
        case 'fsck_file':
            set_fsck_options($task);
            $task->full_path = get_share_landing_zone($task->share) . '/' . $task->full_path;
            $file_type = @filetype($task->full_path);
            list($path, $filename) = explode_full_path($task->full_path);
            FSCKLogFile::loadFSCKReport('Missing files'); // Create or load the fsck_report from disk
            gh_fsck_file($path, $filename, $file_type, 'metastore', $task->share);
            if (task_has_option($task, OPTION_EMAIL)) {
                // Save the report to disk to be able to email it when we're done with all fsck_file tasks
                FSCKLogFile::saveFSCKReport();
            }
            break;
        case 'md5':
            gh_check_md5($task);
            break;
        case 'fsck':
            $new_conf_md5 = get_conf_md5();
            if (task_has_option($task, OPTION_IF_CONF_CHANGED)) {
                // Let's check if the conf file changed since the last fsck

                // Last value
                $last_md5 = Settings::get('last_fsck_conf_md5');
                
                // New value
                if ($new_conf_md5 == $last_md5) {
                    Log::info("Skipping fsck; --if-conf-changed was specified, and the configuration file didn't change since the last fsck.");
                    break;
                }
            }

            $fscked_dir = $task->share;

            $where_clause = "";
            $params = array();
            if ($fscked_dir == '') {
                $fsck_what_dir = 'All shares';
            } else {
                $fsck_what_dir = $fscked_dir;
                $max_lz_length = 0;
                foreach (SharesConfig::getShares() as $share_name => $share_options) {
                    if (strpos($fsck_what_dir, $share_options[CONFIG_LANDING_ZONE]) === 0 && strlen($share_options[CONFIG_LANDING_ZONE]) > $max_lz_length) {
                        $max_lz_length = strlen($share_options[CONFIG_LANDING_ZONE]);
                        $where_clause = "AND share = :share";
                        $params['share'] = $share_name;
                    }
                }
            }

            // First, let's remove all md5 tasks that would be duplicates of the ones we'll create during this fsck
            DB::execute("DELETE FROM tasks WHERE action = 'md5' $where_clause", $params);

            // Second, let's make sure all fsck_file tasks marked idle get executed.
            $query = "UPDATE tasks SET complete = 'yes' WHERE action = 'fsck_file' AND complete = 'idle' AND id < $task->id $where_clause";
            DB::execute($query, $params);
            $num_updated_rows = DB::getFirstValue("SELECT COUNT(*) AS num_updated_rows FROM tasks WHERE action = 'fsck_file' AND complete = 'yes' AND id < $task->id $where_clause", $params);
            if ($num_updated_rows > 0) {
                // Updated some fsck_file to complete; let's just return here, to allow them to be executed first.
                Log::info("Will execute all ($num_updated_rows) pending fsck_file operations for $fsck_what_dir before running this fsck (task ID $task->id).");
                return;
            }

            Log::info("Starting fsck for $fsck_what_dir");
            initialize_fsck_report($fsck_what_dir);
            clearstatcache();

            if (task_has_option($task, OPTION_CHECKSUMS)) {
                // Spawn md5 worker threads; those will calculate files MD5, and save the result in the DB.
                // The Greyhole daemon will then read those, and check them against each other to make sure all is fine.
                $checksums_thread_ids = array();
                foreach (Config::storagePoolDrives() as $sp_drive) {
                    $checksums_thread_ids[] = spawn_thread('md5-worker', array($sp_drive));
                }
                Log::debug("Spawned " . count($checksums_thread_ids) . " worker threads to calculate MD5 checksums. Will now wait for results, and check them as they come in.");
            }

            set_fsck_options($task);

            if ($fscked_dir == '') {
                foreach (SharesConfig::getShares() as $share_name => $share_options) {
                    gh_fsck_reset_du($share_name);
                    gh_fsck($share_options[CONFIG_LANDING_ZONE], $share_name);
                }
                if (!task_has_option($task, OPTION_SKIP_METASTORE)) {
                    foreach (get_metastores() as $metastore) {
                        foreach (SharesConfig::getShares() as $share_name => $share_options) {
                            gh_fsck_metastore($metastore, "/$share_name", $share_name);
                        }
                    }
                }
                if (task_has_option($task, OPTION_ORPHANED)) {
                    foreach (Config::storagePoolDrives() as $sp_drive) {
                        if (StoragePool::is_pool_drive($sp_drive)) {
                            foreach (SharesConfig::getShares() as $share_name => $share_options) {
                                gh_fsck("$sp_drive/$share_name", $share_name, $sp_drive);
                            }
                        }
                    }
                }
            } else {
                $storage_volume = FALSE;
                $share_options = get_share_options_from_full_path($fscked_dir);
                if ($share_options === FALSE) {
                    // Since share_options is FALSE we didn't get a share path, maybe we got a storage volume path, let's check 
                    $storage_volume = get_storage_volume_from_path($fscked_dir);
                    $share_options = get_share_options_from_storage_volume($fscked_dir, $storage_volume);
                }
                Log::debug("  Storage volume? " . ($storage_volume ? $storage_volume : 'No'));
                Log::debug("  Share? " . ($share_options ? $share_options['name'] : 'No'));

                if ($share_options === FALSE) {
                    if ($storage_volume !== FALSE) {
                        // fsck a full storage pool drive
                        foreach (SharesConfig::getShares() as $share_name => $share_options) {
                            gh_fsck("$storage_volume/$share_name", $share_name, $storage_volume);
                        }
                    } else {
                        Log::error("Unknown folder to fsck. You should specify a storage pool folder, a metadata store folder, a shared folder, or a subdirectory of any of those.");
                    }
                } else {
                    $share = $share_options['name'];
                    $metastore = get_metastore_from_path($fscked_dir);

                    if ($storage_volume === FALSE && $metastore === FALSE) {
                        $fsck_type = FSCK_TYPE_SHARE;
                    } else if ($storage_volume !== FALSE) {
                        $fsck_type = FSCK_TYPE_STORAGE_POOL_DRIVE;
                    } else {
                        $fsck_type = FSCK_TYPE_METASTORE;
                    }

                    // Only calculate du stats if the user specified a folder in a share
                    if ($fsck_type == FSCK_TYPE_SHARE) {
                        $subdir = trim(str_replace($share_options[CONFIG_LANDING_ZONE], '', $fscked_dir), '/');
                        gh_fsck_reset_du($share, $subdir);
                    }
                        
                    // Only kick off an fsck on the passed dir if it's not a metastore; that will be handled below.
                    if ($fsck_type != FSCK_TYPE_METASTORE) {
                        gh_fsck($fscked_dir, $share, $storage_volume);
                    }

                    Log::debug("  Scan metadata stores? " . (task_has_option($task, OPTION_SKIP_METASTORE) ? 'No' : 'Yes'));
                    if (task_has_option($task, OPTION_SKIP_METASTORE) === FALSE) {
                        if ($fsck_type == FSCK_TYPE_METASTORE) {
                            // This is a metastore directory, so only kick off a metastore fsck for the indicated directory (this will not fsck the corresponding metastore path on other volumes)
                            $subdir = str_replace("$metastore", '', $fscked_dir);
                            Log::debug("Starting metastore fsck for $metastore/$subdir");
                            gh_fsck_metastore($metastore, $subdir, $share);
                        } else {
                            // This isn't a metastore dir so we'll check the metastore of this path on all volumes
                            if ($fsck_type == FSCK_TYPE_STORAGE_POOL_DRIVE) {
                                $subdir = str_replace($storage_volume, '', $fscked_dir);
                            } else {
                                $subdir = "/$share" . str_replace($share_options[CONFIG_LANDING_ZONE], '', $fscked_dir);
                            }
                            Log::debug("Starting metastores fsck for $subdir");
                            foreach (get_metastores() as $metastore) {
                                gh_fsck_metastore($metastore, $subdir, $share);
                            }
                        }
                    }
                    if ($fsck_type != FSCK_TYPE_STORAGE_POOL_DRIVE && task_has_option($task, OPTION_ORPHANED)) {
                        $subdir = "/$share" . str_replace($share_options[CONFIG_LANDING_ZONE], '', $fscked_dir);
                        Log::debug("Starting orphans search for $subdir");
                        foreach (Config::storagePoolDrives() as $sp_drive) {
                            if (StoragePool::is_pool_drive($sp_drive)) {
                                gh_fsck("$sp_drive/$subdir", $share, $sp_drive);
                            }
                        }
                    }
                }
            }
            Log::info("fsck for " . ($fscked_dir == '' ? 'All shares' : $fscked_dir) . " completed.");
            
            Settings::set('last_fsck_conf_md5', $new_conf_md5);
            
            if (task_has_option($task, OPTION_EMAIL)) {
                // Email report for fsck
                $fsck_report_mail = get_fsck_report();
                $email_to = Config::get(CONFIG_EMAIL_TO);
                Log::debug("Sending fsck report to $email_to");
                mail($email_to, 'fsck of Greyhole shares on ' . exec('hostname'), $fsck_report_mail);
            }
            break;
        case 'mkdir':
            break;
        case 'write':
            $result = gh_write($task->share, $task->full_path, $task->id);
            if (!$result) {
                return;
            }
            break;
        case 'rename':
            $fix_symlinks_scanned_dirs = array();
            $result = gh_mv($task->share, $task->full_path, $task->additional_info, $task->id);
            if (!$result) {
                return;
            }
            break;
        case 'unlink':
            gh_unlink($task->share, $task->full_path, $task->id);
            break;
        case 'rmdir':
            gh_rmdir($task->share, $task->full_path);
            break;
    }
    if ($task->action != 'write' && $task->action != 'rename') {
        $sleep_before_task = array();
    }
    archive_task($task->id);
}

function archive_task($task_id) {
    $query = "INSERT INTO tasks_completed SELECT * FROM tasks WHERE id = :task_id";
    $worked = DB::insert($query, array('task_id' => $task_id));
    if (!$worked) {
        // Let's try a second time... This is kinda important!
        DB::connect();
        DB::insert($query, array('task_id' => $task_id));
    }

    $query = "DELETE FROM tasks WHERE id = :task_id";
    DB::execute($query, array('task_id' => $task_id));
}

function gh_rmdir($share, $full_path) {
    $landing_zone = get_share_landing_zone($share);
    if (!$landing_zone) {
        return;
    }
    
    Log::info("Directory deleted: $landing_zone/$full_path");
    
    if (array_contains(ConfigHelper::$trash_share_names, $share)) {
        // Remove that directory from all trashes
        foreach (Config::storagePoolDrives() as $sp_drive) {
            if (@rmdir("$sp_drive/.gh_trash/$full_path")) {
                Log::debug("  Removed copy from trash at $sp_drive/.gh_trash/$full_path");
            }
        }
        return;
    }

    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (@rmdir("$sp_drive/$share/$full_path/")) {
            Log::debug("  Removed copy at $sp_drive/$share/$full_path");
        }
        $metastore = "$sp_drive/.gh_metastore";
        if (@rmdir("$metastore/$share/$full_path/")) {
            Log::debug("  Removed metadata files directory $metastore/$share/$full_path");
        }
    }
}

function gh_unlink($share, $full_path, $task_id) {
    $landing_zone = get_share_landing_zone($share);
    if (!$landing_zone) {
        return;
    }

    if (should_ignore_file($share, $full_path)) {
        return;
    }

    Log::info("File deleted: $landing_zone/$full_path");
    
    if (array_contains(ConfigHelper::$trash_share_names, $share)) {
        // Will delete the file in the trash which has no corresponding symlink in the Greyhole Trash share.
        // That symlink is what was deleted from that share to create the task we're currently working on.
        $full_path = preg_replace('/ copy [0-9]+$/', '', $full_path);
        Log::debug("  Looking for corresponding file in trash to delete...");
        foreach (Config::storagePoolDrives() as $sp_drive) {
            if (file_exists("$sp_drive/.gh_trash/$full_path")) {
                $delete = TRUE;

                $trash_share = SharesConfig::getConfigForShare(CONFIG_TRASH_SHARE);
                if ($trash_share) {
                    list($path, $filename) = explode_full_path("{$trash_share[CONFIG_LANDING_ZONE]}/$full_path");
                    if ($dh = @opendir($path)) {
                        while (($file = readdir($dh)) !== FALSE) {
                            if ($file == '.' || $file == '..') { continue; }
                            if (is_link("$path/$file") && readlink("$path/$file") == "$sp_drive/.gh_trash/$full_path") {
                                $delete = FALSE;
                                continue;
                            }
                        }
                    }
                }

                if ($delete) {
                    Log::debug("    Deleting corresponding copy $sp_drive/.gh_trash/$full_path");
                    unlink("$sp_drive/.gh_trash/$full_path");
                    break;
                }
            }
        }
        return;
    }

    if (gh_file_exists("$landing_zone/$full_path") && !is_dir("$landing_zone/$full_path")) {
        Log::debug("  File still exists in landing zone; a new file replaced the one deleted here. Skipping.");
        return;
    }

    list($path, $filename) = explode_full_path($full_path);

    foreach (get_metafiles($share, $path, $filename, TRUE) as $existing_metafiles) {
        foreach ($existing_metafiles as $metafile) {
            gh_recycle($metafile->path);
        }
    }
    remove_metafiles($share, $path, $filename);
}

function is_a_metastore_dir($share, $full_path) {
    foreach (get_metastores() as $metastore) {
        if (is_dir("$metastore/$share/$full_path")) {
            return TRUE;
        }
    }
    return FALSE;
}

function gh_mv($share, $full_path, $target_full_path, $task_id) {
    global $sleep_before_task;
    $landing_zone = get_share_landing_zone($share);
    if (!$landing_zone) {
        return TRUE;
    }
    
    if (should_ignore_file($share, $target_full_path)) {
        return TRUE;
    }

    if (is_dir("$landing_zone/$target_full_path") || is_a_metastore_dir($share, $full_path)) {
        Log::info("Directory renamed: $landing_zone/$full_path -> $landing_zone/$target_full_path");

        foreach (Config::storagePoolDrives() as $sp_drive) {
            if (!StoragePool::is_pool_drive($sp_drive)) {
                continue;
            }
            list($original_path, $dirname) = explode_full_path(get_share_landing_zone($share) . "/$target_full_path");

            if (is_dir("$sp_drive/$share/$full_path")) {
                # Make sure the parent directory of target_full_path exists, before we try moving something there...
                list($path, $dirname) = explode_full_path("$sp_drive/$share/$target_full_path");
                gh_mkdir($path, $original_path);

                gh_rename("$sp_drive/$share/$full_path", "$sp_drive/$share/$target_full_path");

                // Make sure all the copies of this folder have the right owner & permissions
                $dir_infos = gh_get_file_infos("$landing_zone/$target_full_path");
                chown("$sp_drive/$share/$target_full_path", $dir_infos->fileowner);
                chgrp("$sp_drive/$share/$target_full_path", $dir_infos->filegroup);
                chmod("$sp_drive/$share/$target_full_path", $dir_infos->fileperms);

                Log::debug("  Directory moved: $sp_drive/$share/$full_path -> $sp_drive/$share/$target_full_path");
            }

            list($path, $dirname) = explode_full_path("$sp_drive/.gh_metastore/$share/$target_full_path");
            gh_mkdir($path, $original_path);
            $result = @gh_rename("$sp_drive/.gh_metastore/$share/$full_path", "$sp_drive/.gh_metastore/$share/$target_full_path");
            if ($result) {
                Log::debug("  Metadata Store directory moved: $sp_drive/.gh_metastore/$share/$full_path -> $sp_drive/.gh_metastore/$share/$target_full_path");
            }
            $result = @gh_rename("$sp_drive/.gh_metastore_backup/$share/$full_path", "$sp_drive/.gh_metastore_backup/$share/$target_full_path");
            if ($result) {
                Log::debug("  Backup Metadata Store directory moved: $sp_drive/.gh_metastore_backup/$share/$full_path -> $sp_drive/.gh_metastore_backup/$share/$target_full_path");
            }
        }

        // Let look in the LZ too, for files we didn't process yet (maybe the folder was ignored before it was renamed)
        exec('find ' . escapeshellarg("$landing_zone/$target_full_path") . ' -type f', $files_in_lz);
        foreach ($files_in_lz as $file_in_lz) {
            list($file_path, $filename) = explode_full_path($file_in_lz);
            gh_fsck_file($file_path, $filename, 'file', 'landing_zone', $share);
        }

        foreach (get_metafiles($share, $target_full_path, null, FALSE, FALSE, FALSE) as $existing_metafiles) {
            Log::debug("Existing metadata files: " . count($existing_metafiles));
            foreach ($existing_metafiles as $file_path => $file_metafiles) {
                Log::debug("  File metafiles: " . count($file_metafiles));
                $new_file_metafiles = array();
                $symlinked = FALSE;
                foreach ($file_metafiles as $key => $metafile) {
                    $old_path = $metafile->path;
                    $metafile->path = str_replace("/$share/$full_path/$file_path", "/$share/$target_full_path/$file_path", $metafile->path);
                    Log::debug("  Changing metadata file: $old_path -> $metafile->path");
                    $new_file_metafiles[$metafile->path] = $metafile;

                    // is_linked = is the target of the existing symlink
                    if ($metafile->is_linked) {
                        $symlinked = TRUE;
                        $symlink_target = $metafile->path;
                    }
                }
                if (!$symlinked && count($file_metafiles) > 0) {
                    // None of the metafiles were is_linked; use the last one for the symlink.
                    $metafile->is_linked = TRUE;
                    $file_metafiles[$key] = $metafile;
                    $symlink_target = $metafile->path;
                }
                
                if (is_link("$landing_zone/$target_full_path/$file_path") && !empty($symlink_target) && readlink("$landing_zone/$target_full_path/$file_path") != $symlink_target) {
                    Log::debug("  Updating symlink at $landing_zone/$target_full_path/$file_path to point to $symlink_target");
                    unlink("$landing_zone/$target_full_path/$file_path");
                    gh_symlink($symlink_target, "$landing_zone/$target_full_path/$file_path");
                } else if (is_link("$landing_zone/$full_path/$file_path") && !empty($symlink_target) && !file_exists(readlink("$landing_zone/$full_path/$file_path"))) {
                    Log::debug("  Updating symlink at $landing_zone/$full_path/$file_path to point to $symlink_target");
                    unlink("$landing_zone/$full_path/$file_path");
                    gh_symlink($symlink_target, "$landing_zone/$full_path/$file_path");
                } else {
                    fix_symlinks($landing_zone, $share, "$full_path/$file_path", "$target_full_path/$file_path");
                }
                
                list($path, $filename) = explode_full_path("$target_full_path/$file_path");
                save_metafiles($share, $path, $filename, $new_file_metafiles);
            }
        }
    } else {
        Log::info("File renamed: $landing_zone/$full_path -> $landing_zone/$target_full_path");
        
        // Check if another process locked this file before we work on it.
        global $locked_files, $locked_shares;
        if (isset($locked_files[clean_dir("$share/$target_full_path")]) || ($locked_by = file_is_locked($share, $target_full_path)) !== FALSE) {
            Log::debug("  File $landing_zone/$target_full_path is locked by another process (" . $locked_files[clean_dir("$share/$target_full_path")] . "). Will wait until it's unlocked to work on any file in this share.");
            $locked_files[clean_dir("$share/$target_full_path")] = isset($locked_by) ? $locked_by : TRUE;
            $locked_shares[$share] = TRUE;
            return FALSE;
        }

        list($path, $filename) = explode_full_path($full_path);
        list($target_path, $target_filename) = explode_full_path($target_full_path);

        foreach (get_metafiles($share, $path, $filename, FALSE, FALSE, FALSE) as $existing_metafiles) {
            // There might be old metafiles... for example, when a delete task was skipped.
            // Let's remove the file copies if there are any leftovers; correct copies will be re-created below.
            if (file_exists("$landing_zone/$target_full_path") && (count($existing_metafiles) > 0 || !is_link("$landing_zone/$target_full_path"))) {
                foreach (get_metafiles($share, $target_path, $target_filename, TRUE, FALSE, FALSE) as $existing_target_metafiles) {
                    if (count($existing_target_metafiles) > 0) {
                        foreach ($existing_target_metafiles as $metafile) {
                            gh_recycle($metafile->path);
                        }
                        remove_metafiles($share, $target_path, $target_filename);
                    }
                }
            }
        
            if (count($existing_metafiles) == 0) {
                // Any NOK metafiles that need to be removed?
                foreach (get_metafiles($share, $path, $filename, TRUE, FALSE, FALSE) as $all_existing_metafiles) {
                    if (count($all_existing_metafiles) > 0) {
                        remove_metafiles($share, $path, $filename);
                    }
                }
                // New file
                gh_write($share, $target_full_path, $task_id);
            } else {
                $symlinked = FALSE;
                foreach ($existing_metafiles as $key => $metafile) {
                    $old_path = $metafile->path;
                    $metafile->path = str_replace("/$share/$full_path", "/$share/$target_full_path", $old_path);
                    Log::debug("  Renaming copy at $old_path to $metafile->path");

                    // Make sure the target directory exists
                    list($metafile_dir_path, $metafile_filename) = explode_full_path($metafile->path);
                    list($original_path, $dirname) = explode_full_path(get_share_landing_zone($share) . "/$target_full_path");
                    gh_mkdir($metafile_dir_path, $original_path);

                    $it_worked = gh_rename($old_path, $metafile->path);

                    if ($it_worked) {
                        // is_linked = is the target of the existing symlink
                        if ($metafile->is_linked) {
                            $symlinked = TRUE;
                            $symlink_target = $metafile->path;
                        }
                    } else {
                        Log::warn("    Warning! An error occured while renaming file copy $old_path to $metafile->path.");
                    }
                    $existing_metafiles[$key] = $metafile;
                }
                if (!$symlinked && count($existing_metafiles) > 0) {
                    // None of the metafiles were is_linked; use the last one for the symlink.
                    $metafile->is_linked = TRUE;
                    $existing_metafiles[$key] = $metafile;
                    $symlink_target = $metafile->path;
                }
                remove_metafiles($share, $path, $filename);
                save_metafiles($share, $target_path, $target_filename, $existing_metafiles);

                if (is_link("$landing_zone/$target_full_path")) {
                    // New link exists...
                    if (readlink("$landing_zone/$target_full_path") != $symlink_target) {
                        // ...and needs to be updated.
                        Log::debug("  Updating symlink at $landing_zone/$target_full_path to point to $symlink_target");
                        unlink("$landing_zone/$target_full_path");
                        gh_symlink($symlink_target, "$landing_zone/$target_full_path");
                    }
                } else if (is_link("$landing_zone/$full_path") && !file_exists(readlink("$landing_zone/$full_path"))) {
                    Log::debug("  Updating symlink at $landing_zone/$full_path to point to $symlink_target");
                    unlink("$landing_zone/$full_path");
                    gh_symlink($symlink_target, "$landing_zone/$full_path");
                } else {
                    fix_symlinks($landing_zone, $share, $full_path, $target_full_path);
                }
            }
        }
    }
    $sleep_before_task = array();
    return TRUE;
}

function fix_symlinks($landing_zone, $share, $full_path, $target_full_path) {
    global $fix_symlinks_scanned_dirs;
    if (isset($fix_symlinks_scanned_dirs[$landing_zone])) {
        return;
    }
    Log::info("  Scanning $landing_zone for broken links... This can take a while!");
    exec("find -L " . escapeshellarg($landing_zone) . " -type l", $broken_links);
    Log::debug("    Found " . count($broken_links) . " broken links.");
    foreach ($broken_links as $broken_link) {
        $fixed_link_target = readlink($broken_link);
        Log::debug("    Found a broken symlink to update: $broken_link. Broken target: $fixed_link_target");
        foreach (Config::storagePoolDrives() as $sp_drive) {
            $fixed_link_target = str_replace(clean_dir("$sp_drive/$share/$full_path/"), clean_dir("$sp_drive/$share/$target_full_path/"), $fixed_link_target);
            if ($fixed_link_target == "$sp_drive/$share/$full_path") {
                $fixed_link_target = "$sp_drive/$share/$target_full_path";
                break;
            }
        }
        if (gh_is_file($fixed_link_target)) {
            Log::debug("      New (fixed) target: $fixed_link_target");
            unlink($broken_link);
            gh_symlink($fixed_link_target, $broken_link);
        }
    }
    $fix_symlinks_scanned_dirs[$landing_zone] = TRUE;
}

function gh_file_exists($real_path, $log_message=null) {
    clearstatcache();
    if (!file_exists($real_path)) {
        if ($log_message != null) {
            eval('$log_message = "' . str_replace('"', '\"', $log_message) . '";');
            Log::info($log_message);
        }
        return FALSE;
    }
    return TRUE;
}

function get_num_copies($share) {
    $num_copies = SharesConfig::get($share, CONFIG_NUM_COPIES);
    if (!$num_copies) {
        Log::warn("Found a task on a share ($share) that disappeared from " . ConfigHelper::$config_file . ". Skipping.");
        return -1;
    }
    if ($num_copies < 1) {
        $num_copies = 1;
    }
    $max_copies = 0;
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (StoragePool::is_pool_drive($sp_drive)) {
            $max_copies++;
        }
    }
    if ($num_copies > $max_copies) {
        $num_copies = $max_copies;
    }
    return $num_copies;
}

function file_is_locked($share, $full_path) {
    if (Config::get(CONFIG_CHECK_FOR_OPEN_FILES) === FALSE) {
        Log::debug("  Skipping open file (lock) check.");
        return FALSE;
    }
    
    $landing_zone = get_share_landing_zone($share);
    if (!$landing_zone) {
        return FALSE;
    }
    
    $real_fullpath = "$landing_zone/$full_path";
    if (is_link($real_fullpath)) {
        $real_fullpath = readlink($real_fullpath);
    }
    $result = exec("lsof -M -n -P -l " . escapeshellarg($real_fullpath) . " 2> /dev/null");
    if (string_contains($result, $real_fullpath)) {
        return $result;
    }

    $query = "SELECT * FROM tasks WHERE complete = 'no' AND action = 'write' AND share = :share AND full_path = :full_path LIMIT 1";
    $params = array('share' => $share, 'full_path' => $full_path);
    $row = DB::getFirst($query, $params);
    if ($row === FALSE) {
        return FALSE;
    }
    
    // Locked, according to DB... But maybe it's not really locked?
    if (!gh_file_exists($real_fullpath)) {
        // File doesn't exists anymore... It can't be really locked... Let's assume this is just Samba that 'forgot' to close the file handle.
        $query = "UPDATE tasks SET complete = 'yes' WHERE complete = 'no' AND action = 'write' AND share = :share AND full_path = :full_path";
        DB::execute($query, $params);
        return FALSE;
    }

    return TRUE;
}

function real_file_is_locked($real_fullpath) {
    if (is_link($real_fullpath)) {
        $real_fullpath = readlink($real_fullpath);
    }
    $result = exec("lsof -M -n -P -l " . escapeshellarg($real_fullpath) . " 2> /dev/null");
    if (string_contains($result, $real_fullpath)) {
        return $result;
    }
    return FALSE;
}

function find_future_full_path($share, $full_path, $task_id) {
    $new_full_path = $full_path;
    while ($next_task = find_next_rename_task($share, $new_full_path, $task_id)) {
        if ($next_task->full_path == $full_path) {
            // File was renamed
            $new_full_path = $next_task->additional_info;
        } else {
            // A parent directory was renamed
            $new_full_path = preg_replace("@^$next_task->full_path@", $next_task->additional_info, $new_full_path);
        }
        $task_id = $next_task->id;
    }
    return $new_full_path;
}

function find_next_rename_task($share, $full_path, $task_id) {
    $full_paths = array();
    $full_paths[] = $full_path;
    $parent_full_path = $full_path;
    list($parent_full_path, $basename) = explode_full_path($parent_full_path);
    while (strlen($parent_full_path) > 1) {
        $full_paths[] = $parent_full_path;
        list($parent_full_path, $basename) = explode_full_path($parent_full_path);
    }
    $query = "SELECT * FROM tasks WHERE complete = 'yes' AND share = :share AND action = 'rename' AND full_path IN ('" . implode("','", array_map("DB::quote", $full_paths)) . "') AND id > :task_id ORDER BY id LIMIT 1";
    return DB::getFirst($query, array('share' => $share, 'task_id' => $task_id));
}

function should_ignore_file($share, $full_path) {
    list($path, $filename) = explode_full_path($full_path);

    foreach (Config::get(CONFIG_IGNORED_FILES) as $ignored_file_re) {
        if (preg_match(';^' . $ignored_file_re . '$;', $filename)) {
            Log::info("Ignoring task because it matches the following '" . CONFIG_IGNORED_FILES . "' pattern: $ignored_file_re");
            return TRUE;
        }
    }
    foreach (Config::get(CONFIG_IGNORED_FOLDERS) as $ignored_folder_re) {
        $p = clean_dir("$share/$path/");
        if (preg_match(';^' . $ignored_folder_re . '$;', $p)) {
            Log::info("Ignoring task because it matches the following '" . CONFIG_IGNORED_FOLDERS . "' pattern: $ignored_folder_re");
            return TRUE;
        }
    }

    return FALSE;
}

function gh_write($share, $full_path, $task_id) {
    $landing_zone = get_share_landing_zone($share);
    if (!$landing_zone) {
        return TRUE;
    }

    if (should_ignore_file($share, $full_path)) {
        return TRUE;
    }
    
    if (!gh_file_exists("$landing_zone/$full_path", '$real_path doesn\'t exist anymore.')) {
        $new_full_path = find_future_full_path($share, $full_path, $task_id);
        if ($new_full_path != $full_path && gh_is_file("$landing_zone/$new_full_path")) {
            Log::debug("  Found that $full_path has been renamed to $new_full_path. Will work using that instead.");
            if (is_link("$landing_zone/$new_full_path")) {
                $source_file = clean_dir(readlink("$landing_zone/$new_full_path"));
            } else {
                $source_file = clean_dir("$landing_zone/$new_full_path");
            }
        } else {
            Log::info("  Skipping.");
            if (!gh_file_exists($landing_zone, '  Share "' . $share . '" landing zone "$real_path" doesn\'t exist anymore. Will not process this task until it re-appears...')) {
                postpone_task($task_id);
            }
            return TRUE;
        }
    }
    
    $num_copies_required = get_num_copies($share);
    if ($num_copies_required === -1) {
        return TRUE;
    }

    list($path, $filename) = explode_full_path($full_path);

    if ((isset($new_full_path) && is_link("$landing_zone/$new_full_path")) || is_link("$landing_zone/$full_path")) {
        if (!isset($source_file)) {
            $source_file = clean_dir(readlink("$landing_zone/$full_path"));
        }
        clearstatcache();
        $filesize = gh_filesize($source_file);
        if (Log::getLevel() >= Log::DEBUG) {
            Log::info("File changed: $share/$full_path - " . bytes_to_human($filesize, FALSE));
        } else {
            Log::info("File changed: $share/$full_path");
        }
        Log::debug("  Will use source file: $source_file");

        foreach (get_metafiles($share, $path, $filename, TRUE) as $existing_metafiles) {
            // Remove old copies (but not the one that was updated!)
            $keys_to_remove = array();
            $found_source_file = FALSE;
            foreach ($existing_metafiles as $key => $metafile) {
                $metafile->path = clean_dir($metafile->path);
                if ($metafile->path == $source_file) {
                    $metafile->is_linked = TRUE;
                    $metafile->state = 'OK';
                    $found_source_file = TRUE;
                } else {
                    Log::debug("  Will remove copy at $metafile->path");
                    $keys_to_remove[] = $metafile->path;
                }
            }
            if (!$found_source_file && count($keys_to_remove) > 0) {
                // This shouldn't happen, but if we're about to remove all copies, let's make sure we keep at least one.
                $key = array_shift($keys_to_remove);
                $source_file = $existing_metafiles[$key]->path;
                Log::debug("  Change of mind... Will use source file: $source_file");
            }
            $new_metafiles = gh_write_process_metafiles($num_copies_required, $existing_metafiles, $share, $full_path, $source_file, $filesize, $task_id, $keys_to_remove);
            if ($new_metafiles === FALSE) {
                return FALSE;
            }
            if (!empty($new_metafiles) && !isset($new_metafiles[$source_file])) {
                // Delete source file; we copied it somewhere else
                // Let's just make sure we have at least one OK file before we delete it!
                Log::debug("  Source file is not needed anymore. Deleting...");
                $is_ok = FALSE;
                foreach ($new_metafiles as $metafile) {
                    if ($metafile->state == 'OK') {
                        $is_ok = TRUE;
                        break;
                    }
                }
                if ($is_ok) {
                    // Ok, now we're sure.
                    gh_recycle($source_file, TRUE);
                } else {
                    Log::debug("  Change of mind... Couldn't find any OK metadata file... Will keep the source!");
                }
            }
        }
    } else {
        if (!isset($source_file)) {
            $source_file = clean_dir("$landing_zone/$full_path");
        }
        clearstatcache();
        $filesize = gh_filesize($source_file);
        if (Log::getLevel() >= Log::DEBUG) {
            Log::info("File created: $share/$full_path - " . bytes_to_human($filesize, FALSE));
        } else {
            Log::info("File created: $share/$full_path");
        }

        if (is_dir($source_file)) {
            Log::info("$share/$full_path is now a directory! Aborting.");
            return TRUE;
        }

        // There might be old metafiles... for example, when a delete task was skipped.
        // Let's remove the file copies if there are any leftovers; correct copies will be re-created in create_copies_from_metafiles()
        foreach (get_metafiles($share, $path, $filename) as $existing_metafiles) {
            Log::debug(count($existing_metafiles) . " metafiles loaded.");
            if (count($existing_metafiles) > 0) {
                foreach ($existing_metafiles as $metafile) {
                    gh_recycle($metafile->path);
                }
                remove_metafiles($share, $path, $filename);
                $existing_metafiles = array();
                // Maybe there's other file copies, that weren't metafiles, or were NOK metafiles!
                foreach (Config::storagePoolDrives() as $sp_drive) {
                    if (file_exists("$sp_drive/$share/$path/$filename")) {
                        gh_recycle("$sp_drive/$share/$path/$filename");
                    }
                }
            }
            $new_metafiles = gh_write_process_metafiles($num_copies_required, $existing_metafiles, $share, $full_path, $source_file, $filesize, $task_id);
            if ($new_metafiles === FALSE) {
                return FALSE;
            }
        }
    }
    return TRUE;
}

function gh_write_process_metafiles($num_copies_required, $existing_metafiles, $share, $full_path, $source_file, $filesize, $task_id, $keys_to_remove=NULL) {
    $landing_zone = get_share_landing_zone($share);
    list($path, $filename) = explode_full_path($full_path);

    // Only need to check for locking if we have something to do!
    if ($num_copies_required > 1 || count($existing_metafiles) == 0) {
        // Check if another process locked this file before we work on it.
        global $locked_files, $locked_shares;
        if (isset($locked_files[clean_dir("$share/$full_path")]) || ($locked_by = file_is_locked($share, $full_path)) !== FALSE) {
            Log::debug("  File $landing_zone/$full_path is locked by another process (" . ( isset($locked_files[clean_dir("$share/$full_path")]) ? $locked_files[clean_dir("$share/$full_path")] : $locked_by ) . "). Will wait until it's unlocked to work on any file in this share.");
            $locked_files[clean_dir("$share/$full_path")] = isset($locked_by) ? $locked_by : TRUE;
            $locked_shares[$share] = TRUE;
            return FALSE;
        }
        global $sleep_before_task;
        $sleep_before_task = array();
    }

    if ($keys_to_remove !== NULL) {
        foreach ($keys_to_remove as $key) {
            if ($existing_metafiles[$key]->path != $source_file) {
                gh_recycle($existing_metafiles[$key]->path, TRUE);
            }
        }
        // Empty the existing metafiles array, to be able to recreate all new copies on the correct drives, per the dir_selection_algorithm
        $existing_metafiles = array();
    }

    $metafiles = create_metafiles($share, $full_path, $num_copies_required, $filesize, $existing_metafiles);

    if (count($metafiles) == 0) {
        Log::warn("  No metadata files could be created. Will wait until metadata files can be created to work on this file.");
        postpone_task($task_id);
        return array();
    }

    if (!is_link("$landing_zone/$full_path")) {
        // Use the 1st metafile for the symlink; it might be on a sticky drive.
        $i = 0;
        foreach ($metafiles as $metafile) {
            $metafile->is_linked = ($i++ == 0);
        }
    }

    save_metafiles($share, $path, $filename, $metafiles);

    create_copies_from_metafiles($metafiles, $share, $full_path, $source_file);

    return $metafiles;
}

function create_copies_from_metafiles($metafiles, $share, $full_path, $source_file, $missing_only=FALSE) {
    $landing_zone = get_share_landing_zone($share);
    
    list($path, $filename) = explode_full_path($full_path);
    
    $source_file = clean_dir($source_file);

    $link_next = FALSE;
    $file_infos = gh_get_file_infos("$landing_zone/$full_path");
    foreach ($metafiles as $key => $metafile) {
        if (!gh_file_exists("$landing_zone/$full_path", '  $real_path doesn\'t exist anymore. Aborting.')) { return; }
        
        if ($metafile->path == $source_file && $metafile->state == 'OK' && gh_filesize($metafile->path) == gh_filesize($source_file)) {
            Log::debug("  File copy at $metafile->path is already up to date.");
            continue;
        }
        
        if ($missing_only && gh_file_exists($metafile->path) && $metafile->state == 'OK' && gh_filesize($metafile->path) == gh_filesize($source_file)) {
            Log::debug("  File copy at $metafile->path is already up to date.");
            continue;
        }

        $root_path = str_replace(clean_dir("/$share/$full_path"), '', $metafile->path);
        if (!StoragePool::is_pool_drive($root_path)) {
            Log::warn("  Warning! It seems the partition UUID of $root_path changed. This probably means this mount is currently unmounted, or that you replaced this drive and didn't use 'greyhole --replace'. Because of that, Greyhole will NOT use this drive at this time.");
            $metafile->state = 'Gone';
            $metafiles[$key] = $metafile;
            continue;
        }

        list($metafile_dir_path, $metafile_filename) = explode_full_path($metafile->path);

        list($original_path, $metafile_filename) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
        if (!gh_mkdir($metafile_dir_path, $original_path)) {
            $metafile->state = 'Gone';
            $metafiles[$key] = $metafile;
            continue;
        }

        if (!gh_copy_file($source_file, $metafile->path)) {
            if ($metafile->is_linked) {
                $metafile->is_linked = FALSE;
                $link_next = TRUE;
            }
            $metafile->state = 'Gone';
            gh_recycle($metafile->path);
            $metafiles[$key] = $metafile;
            save_metafiles($share, $path, $filename, $metafiles);

            if (file_exists("$landing_zone/$full_path")) {
                global $current_task_id;
                if ($current_task_id === 0) {
                    Log::error("    Failed file copy (cont). We already retried this task. Aborting.");
                    return;
                }
                Log::warn("    Failed file copy (cont). Will try to re-process this write task, since the source file seems intact.");
                // Queue a new write task, to replace the now gone copy.
                global $next_task;
                $next_task = (object) array(
                    'id' => 0,
                    'action' => 'write',
                    'share' => $share, 
                    'full_path' => clean_dir($full_path),
                    'complete' => 'yes'
                );
                return;
            }
            continue;
        }

        if ($link_next && !$metafile->is_linked) {
            $metafile->is_linked = TRUE;
            $metafiles[$key] = $metafile;
        }
        $link_next = FALSE;
        if ($metafile->is_linked) {
            Log::debug("    Creating symlink in share pointing to the above file copy.");
            gh_symlink($metafile->path, "$landing_zone/$path/.gh_$filename");
            if (!file_exists("$landing_zone/$full_path") || unlink("$landing_zone/$full_path")) {
                gh_rename("$landing_zone/$path/.gh_$filename", "$landing_zone/$path/$filename");
            } else {
                unlink("$landing_zone/$path/.gh_$filename");
            }
        }

        if (gh_file_exists($metafile->path, '  Copy at $real_path doesn\'t exist. Will not mark it OK!')) {
            $metafile->state = 'OK';
            $metafiles[$key] = $metafile;
        }
        save_metafiles($share, $path, $filename, $metafiles);
    }
}

function gh_copy_file($source_file, &$destination_file) {
    $start_time = time();
    $source_size = gh_filesize($source_file);
    $temp_path = get_temp_filename($destination_file);

    if (is_link($source_file)) {
        $link_target = readlink($source_file);
        $source_size = gh_filesize($link_target);
    } else if (gh_is_file($source_file)) {
        $source_size = gh_filesize($source_file);
    }

    if (isset($source_size)) {
        Log::debug("  Copying " . bytes_to_human($source_size, FALSE) . " file to $destination_file");
    } else {
        Log::debug("  Copying file to $destination_file");
    }

    $renamed = FALSE;
    if (gh_is_file($source_file)) {
        $source_dev = gh_file_deviceid($source_file);
        $target_dev = gh_file_deviceid(dirname($destination_file));
        if ($source_dev === $target_dev && $source_dev !== FALSE && !Config::get(CONFIG_ALLOW_MULTIPLE_SP_PER_DRIVE)) {
            Log::debug("  (using rename)");
            $original_file_infos = gh_get_file_infos($source_file);
            gh_rename($source_file, $temp_path);
            $renamed = TRUE;
        }
    }

    if (!$renamed) {
        // Wasn't renamed; need to be copied.
        $copy_source = is_link($source_file) ? readlink($source_file) : $source_file;
        $original_file_infos = gh_get_file_infos($copy_source);
        exec(get_copy_cmd($copy_source, $temp_path));
    }

    $it_worked = file_exists($temp_path) && ($renamed || file_exists($source_file)) && gh_filesize($temp_path) == $source_size;
    if (!$it_worked) {
        // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
        $it_worked = file_exists(normalize_utf8_characters($temp_path)) && ($renamed || file_exists($source_file)) && gh_filesize($temp_path) == $source_size;
        if ($it_worked) {
            // Bingo!
            $temp_path = normalize_utf8_characters($temp_path);
            $destination_file = normalize_utf8_characters($destination_file);
        }
    }
    if ($it_worked) {
        if (time() - $start_time > 0) {
            $speed = number_format($source_size/1024/1024 / (time() - $start_time), 1);
            Log::debug("    Copy created at $speed MBps.");
        }
        gh_rename($temp_path, $destination_file);
        gh_chperm($destination_file, $original_file_infos);
    } else {
        Log::warn("    Failed file copy. Will mark this metadata file 'Gone'.");
        if ($renamed) {
            // Do NOT delete $temp_path if the file was renamed... Just move it back!
            gh_rename($temp_path, $source_file);
        } else {
            // Remove the failed copy, if any.
            @unlink($temp_path);
        }
    }
    return $it_worked;
}

function gh_chperm($real_file_path, $file_infos) {
    chmod($real_file_path, $file_infos->fileperms);
    chown($real_file_path, $file_infos->fileowner);
    chgrp($real_file_path, $file_infos->filegroup);
    touch($real_file_path, $file_infos->filemtime, time());
}

function gh_mkdir($directory, $original_directory_or_dir_infos) {
    if (is_string($original_directory_or_dir_infos)) {
        $dir_infos = gh_get_file_infos($original_directory_or_dir_infos);
    } else {
        $dir_infos = $original_directory_or_dir_infos;
    }
    if (is_dir($directory)) {
        if (!chown($directory, $dir_infos->fileowner)) {
            Log::warn("  Failed to chown directory '$directory'");
        }
        if (!chgrp($directory, $dir_infos->filegroup)) {
            Log::warn("  Failed to chgrp directory '$directory'");
        }
        if (!chmod($directory, $dir_infos->fileperms)) {
            Log::warn("  Failed to chmod directory '$directory'");
        }
    } else {
        // Need to mkdir & chown/chgrp all dirs that don't exists, up to the full path ($directory)
        $dir_parts = explode('/', $directory);
        
        $i = 0;
        $parent_directory = clean_dir('/' . $dir_parts[$i++]);
        while (is_dir($parent_directory) && $i < count($dir_parts)) {
            $parent_directory = clean_dir($parent_directory . '/' . $dir_parts[$i++]);
        }
        while ($i <= count($dir_parts)) {
            if (!is_dir($parent_directory) && !@mkdir($parent_directory, $dir_infos->fileperms)) {
                if (gh_is_file($parent_directory)) {
                    gh_rename($parent_directory, "$parent_directory (file copy)");
                }
                if (!@mkdir($parent_directory, $dir_infos->fileperms)) {
                    // Even if mkdir return false, the folder might have been correctly created... who would think...
                    if (!is_dir($parent_directory)) {
                        // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
                        if (is_dir(normalize_utf8_characters($parent_directory))) {
                            // Bingo!
                            $parent_directory = normalize_utf8_characters($parent_directory);
                        } else {
                            Log::warn("  Failed to create directory $parent_directory");
                            return FALSE;
                        }
                    }
                }
            }
            if (!chown($parent_directory, $dir_infos->fileowner)) {
                Log::warn("  Failed to chown directory '$parent_directory'");
            }
            if (!chgrp($parent_directory, $dir_infos->filegroup)) {
                Log::warn("  Failed to chgrp directory '$parent_directory'");
            }
            if (!isset($dir_parts[$i])) {
                break;
            }
            $parent_directory = clean_dir($parent_directory . '/' . $dir_parts[$i++]);
        }
    }
    return TRUE;
}

function get_temp_filename($full_path) {
    list($path, $filename) = explode_full_path($full_path);
    return "$path/.$filename." . mb_substr(md5($filename), 0, 5);
}

function is_temp_file($full_path) {
    list($path, $filename) = explode_full_path($full_path);
    if (preg_match("/^\.(.+)\.([0-9a-f]{5})$/", $filename, $regs)) {
        $md5_stem = mb_substr(md5($regs[1]), 0, 5);
        return ($md5_stem == $regs[2]);
    }
    return FALSE;
}

function create_metafiles($share, $full_path, $num_copies_required, $filesize, $metafiles=array()) {
    $found_link_metafile = FALSE;

    list($path, $filename) = explode_full_path($full_path);
    
    $num_ok = count($metafiles);
    foreach ($metafiles as $key => $metafile) {
        $sp_drive = str_replace(clean_dir("/$share/$full_path"), '', $metafile->path);
        if (!StoragePool::is_pool_drive($sp_drive)) {
            $metafile->state = 'Gone';
        }

        // Check free space!
        $dfs = get_free_space_in_storage_pool_drives();
        if (!isset($dfs[$sp_drive])) {
            $free_space = 0;
        } else {
            $free_space = $dfs[$sp_drive]['free'];
        }
        if ($free_space <= $filesize/1024) {
            $metafile->state = 'Gone';
        }
        
        if ($metafile->state != 'OK' && $metafile->state != 'Pending') {
            $num_ok--;
        }
        if ($key != $metafile->path) {
            unset($metafiles[$key]);
            $key = $metafile->path;
        }
        if ($metafile->is_linked) {
            $found_link_metafile = TRUE;
        }
        $metafiles[$key] = $metafile;
    }

    // Select drives that have enough free space for this file
    if ($num_ok < $num_copies_required) {
        $local_target_drives = order_target_drives($filesize/1024, FALSE, $share, $path, '  ');
    }
    while ($num_ok < $num_copies_required && count($local_target_drives) > 0) {
        $sp_drive = array_shift($local_target_drives);
        $clean_target_full_path = clean_dir("$sp_drive/$share/$full_path");
        // Don't use drives that already have a copy
        if (isset($metafiles[$clean_target_full_path])) {
            continue;
        }
        foreach ($metafiles as $metafile) {
            if ($clean_target_full_path == clean_dir($metafile->path)) {
                continue;
            }
        }
        // Prepend new target drives, to make sure sticky directories will be used first
        $metafiles = array_reverse($metafiles);
        $metafiles[$clean_target_full_path] = (object) array('path' => $clean_target_full_path, 'is_linked' => FALSE, 'state' => 'Pending');
        $metafiles = array_reverse($metafiles);
        $num_ok++;
    }
    
    if (!$found_link_metafile) {
        foreach ($metafiles as $metafile) {
            $metafile->is_linked = TRUE;
            break;
        }
    }
    
    return $metafiles;
}

function get_metafile_data_filename($share, $path, $filename) {
    $filenames = get_metafile_data_filenames($share, $path, $filename, 1);
    if (count($filenames) > 0) {
        return $filenames[0];
    }
    return FALSE;
}

function get_metafile_data_filenames($share, $path, $filename, $how_many=9999) {
    $filenames = array();
    foreach (get_metastores() as $metastore) {
        $f = clean_dir("$metastore/$share/$path/$filename");
        if (is_file($f)) {
            $filenames[] = $f;
            if (count($filenames) == $how_many) {
                return $filenames;
            }
        }
    }
    return $filenames;
}

function get_metafiles($share, $path, $filename=null, $load_nok_metafiles=FALSE, $quiet=FALSE, $check_symlink=TRUE) {
    if($filename === null) {
        return new metafile_iterator($share, $path, $load_nok_metafiles, $quiet, $check_symlink);
    }else{
        return array(get_metafiles_for_file($share,$path,$filename,$load_nok_metafiles,$quiet,$check_symlink));
    }    
}

function get_metafiles_for_file($share, $path, $filename=null, $load_nok_metafiles=FALSE, $quiet=FALSE, $check_symlink=TRUE) {
    if (!$quiet) {
        Log::debug("Loading metafiles for " . clean_dir($share . (!empty($path) ? "/$path" : "") . "/$filename") . ' ...');
    }
    $metafiles_data_file = get_metafile_data_filename($share, $path, $filename);
    clearstatcache();
    $metafiles = array();
    if (file_exists($metafiles_data_file)) {
        $t = file_get_contents($metafiles_data_file);
        $metafiles = unserialize($t);
    }

    if ($check_symlink) {
        // Fix wrong 'is_linked' flags
        $share_file = get_share_landing_zone($share) . "/$path/$filename";
        $share_file_link_to = FALSE;
        if (is_link($share_file)) {
            $share_file_link_to = readlink($share_file);
        }
        if (!is_array($metafiles)) {
            $metafiles = array();
        }
        foreach ($metafiles as $key => $metafile) {
            if ($metafile->state == 'OK' && $share_file_link_to !== FALSE) {
                if (@$metafile->is_linked && $metafile->path != $share_file_link_to) {
                    if (!$quiet) {
                        Log::debug('  Changing is_linked to FALSE for ' . $metafile->path);
                    }
                    $metafile->is_linked = FALSE;
                    $metafiles[$key] = $metafile;
                    save_metafiles($share, $path, $filename, $metafiles);
                } else if (empty($metafile->is_linked) && $metafile->path == $share_file_link_to) {
                    if (!$quiet) {
                        Log::debug('  Changing is_linked to TRUE for ' . $metafile->path);
                    }
                    $metafile->is_linked = TRUE;
                    $metafiles[$key] = $metafile;
                    save_metafiles($share, $path, $filename, $metafiles);
                }
            }
        }
    }

    $ok_metafiles = array();
    foreach ($metafiles as $key => $metafile) {
        $valid_path = FALSE;
        
        $drive = get_storage_volume_from_path($metafile->path);
        if ($drive !== FALSE) {
            $valid_path = TRUE;
        }
        if ($valid_path && ($load_nok_metafiles || $metafile->state == 'OK')) {
            $key = clean_dir($metafile->path);
            if (isset($ok_metafiles[$key])) {
                $previous_metafile = $ok_metafiles[$key];
                if ($previous_metafile->state == 'OK' && $metafile->state != 'OK') {
                    // Don't overwrite previous OK metafiles with NOK metafiles that point to the same files!
                    continue;
                }
            }
            $ok_metafiles[$key] = $metafile;
        } else {
            if (!$valid_path) {
                Log::warn("Found a metadata file pointing to a drive not defined in your storage pool: '$metafile->path'. Will mark it as Gone.");
                $metafile->state = 'Gone';
                $metafiles[$key] = $metafile;
                save_metafiles($share, $path, $filename, $metafiles);
            } else {
                #Log::debug("Found a metadata file, pointing to '$metafile->path', with state = '$metafile->state'. We just want 'OK' metadata files; will not use this metadata file.");
            }
        }
    }
    $metafiles = $ok_metafiles;
    
    if (!$quiet) {
        Log::debug("  Got " . count($metafiles) . " metadata files.");
    }
    return $metafiles;
}

function remove_metafiles($share, $path, $filename) {
    Log::debug("  Removing metadata files for $share" . (!empty($path) ? "/$path" : "") . ($filename!== null ? "/$filename" : ""));
    
    foreach (get_metafile_data_filenames($share, $path, $filename) as $f) {
        @unlink($f);
        Log::debug("    Removed metadata file at $f");
        clearstatcache();
    }
}

function save_metafiles($share, $path, $filename, $metafiles) {
    if (count($metafiles) == 0) {
        remove_metafiles($share, $path, $filename);
        return;
    }
    
    // We don't care about the keys (we'll re-create them on load), so let's not waste disk space, and use numeric indexes.
    $metafiles = array_values($metafiles);

    Log::debug("  Saving " . count($metafiles) . " metadata files for " . clean_dir($share . (!empty($path) ? "/$path" : "") . ($filename!== null ? "/$filename" : "")));
    $paths_used = array();
    foreach (get_metastores() as $metastore) {
        $sp_drive = str_replace('/.gh_metastore', '', $metastore);
        $data_filepath = clean_dir("$metastore/$share/$path");
        $has_metafile = FALSE;
        foreach ($metafiles as $metafile) {
            if (get_storage_volume_from_path($metafile->path) == $sp_drive && StoragePool::is_pool_drive($sp_drive)) {
                gh_mkdir($data_filepath, get_share_landing_zone($share) . "/$path");
                Log::debug("    Saving metadata in " . clean_dir("$data_filepath/$filename"));
                if (is_dir("$data_filepath/$filename")) {
                    exec("rm -rf " . escapeshellarg("$data_filepath/$filename"));
                }
                $worked = @file_put_contents("$data_filepath/$filename", serialize($metafiles));
                if ($worked === FALSE) {
                    // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
                    $worked = file_put_contents(normalize_utf8_characters("$data_filepath/$filename"), serialize($metafiles));
                    if ($worked !== FALSE) {
                        // Bingo!
                        $data_filepath = normalize_utf8_characters($data_filepath);
                        $filename = normalize_utf8_characters($filename);
                    }
                }
                $has_metafile = TRUE;
                $paths_used[] = $data_filepath;
                break;
            }
        }
        if (!$has_metafile && file_exists("$data_filepath/$filename")) {
            unlink("$data_filepath/$filename");
        }
    }
    if (count($paths_used) == 1) {
        // Also save a backup on another drive
        $metastore_backup_drives = Config::get(CONFIG_METASTORE_BACKUPS);
        if (!empty($metastore_backup_drives)) {
            if (!string_contains($paths_used[0], str_replace('.gh_metastore_backup', '.gh_metastore', $metastore_backup_drives[0]))) {
                $metastore_backup_drive = $metastore_backup_drives[0];
            } else {
                $metastore_backup_drive = $metastore_backup_drives[1];
            }
            $data_filepath = "$metastore_backup_drive/$share/$path";
            Log::debug("    Saving backup metadata file in $data_filepath/$filename");
            gh_mkdir($data_filepath, get_share_landing_zone($share) . "/$path");
            file_put_contents("$data_filepath/$filename", serialize($metafiles));
        }
    }
}

function update_last_read_log_smbd_line($fp) {
    $f_seek_point = ftell($fp);
    Settings::set('last_read_log_smbd_line', $f_seek_point);
}

function samba_get_version() {
    return str_replace(' ', '.', exec('/usr/sbin/smbd --version | awk \'{print $2}\' | awk -F\'-\' \'{print $1}\' | awk -F\'.\' \'{print $1,$2}\''));
}

function samba_restart() {
      Log::info("The Samba daemon will now restart...");
      if (is_file('/etc/init/smbd.conf')) {
          exec("/sbin/restart smbd");
      } else if (is_file('/etc/init.d/samba')) {
          exec("/etc/init.d/samba restart");
      } else if (is_file('/etc/init.d/smb')) {
          exec("/etc/init.d/smb restart");
      } else if (is_file('/etc/init.d/smbd')) {
          exec("/etc/init.d/smbd restart");
      } else if (is_file('/etc/systemd/system/multi-user.target.wants/smb.service')) {
          exec("systemctl restart smb.service");
      } else {
          Log::critical("Couldn't find how to restart Samba. Please restart the Samba daemon manually.");
      }
}

function samba_check_vfs() {
    $vfs_is_ok = FALSE;

    // Samba version
     $version = str_replace('.', '', samba_get_version());
      
    // CPU architecture (x86_64 or i386 or armv6l or armv5*)
    $arch = exec('uname -m');

      // Find VFS symlink
    if (file_exists('/usr/lib/x86_64-linux-gnu/samba/vfs')) {
        $source_libdir = '/usr/lib64'; # Makefile will always install Greyhole .so files in /usr/lib64, for x86_64 CPUs. @see Makefile
        $target_libdir = '/usr/lib/x86_64-linux-gnu';
    } else if ($arch == "x86_64") {
        $source_libdir = '/usr/lib64';
        $target_libdir = '/usr/lib64';

        # For Ubuntu, where even x86_64 install use /usr/lib
        if (file_exists('/usr/lib/samba/vfs')) {
            $target_libdir = '/usr/lib';
        }
    } else {
        $source_libdir = '/usr/lib';
        $target_libdir = '/usr/lib';
    }

    $vfs_file = "$target_libdir/samba/vfs/greyhole.so";

    Log::debug("Checking symlink at $vfs_file...");
    if (is_file($vfs_file)) {
        // Get VFS symlink target
        $vfs_target = @readlink($vfs_file);
        if (strpos($vfs_target, "/greyhole-samba$version.so") !== FALSE) {
            Log::debug("  Is OK.");
            $vfs_is_ok = TRUE;
        }
    }
    if (!$vfs_is_ok) {
        $vfs_target = "$source_libdir/greyhole/greyhole-samba$version.so";
        Log::warn("  Greyhole VFS module for Samba was missing, or the wrong version for your Samba. It will now be replaced with a symlink to $vfs_target");
        if (is_file($vfs_file)) {
            unlink($vfs_file);
        }
        gh_symlink($vfs_target, $vfs_file);
        samba_restart();
    }

    # Bugfix for Ubuntu 14 (Trusty) that is missing libsmbd_base.so, which is used to compile the VFS
    if (file_exists("$target_libdir/samba/libsmbd_base.so.0") && !file_exists("$target_libdir/samba/libsmbd_base.so")) {
        Log::info("  Ubuntu 14 bugfix: creating symlink pointing to libsmbd_base.so.0 as libsmbd_base.so.");
        gh_symlink("$target_libdir/samba/libsmbd_base.so.0", "$target_libdir/samba/libsmbd_base.so");
    }
}

function create_mem_spool() {
    $mounted_already = exec('mount | grep /var/spool/greyhole/mem | wc -l');
    if (!$mounted_already) {
        if (!file_exists('/var/spool/greyhole/mem')) {
            mkdir('/var/spool/greyhole/mem', 0777, TRUE);
            chmod('/var/spool/greyhole/mem', 0777); // mkdir mode is affected by the umask, so we need to insure proper mode on that folder.
        }
        exec('mount -o size=4M -t tmpfs none /var/spool/greyhole/mem 2> /dev/null', $mount_result);
        if (!empty($mount_result)) {
            Log::error("Error mounting tmpfs in /var/spool/greyhole/mem: $mount_result");
        }
        return TRUE;
    }
    return FALSE;
}

function parse_samba_spool() {
    Log::setAction(ACTION_READ_SAMBA_POOL);

    // Just in case the spool folder is missing!
    if (!file_exists('/var/spool/greyhole/mem')) {
        mkdir('/var/spool/greyhole/mem', 0777, TRUE);
        chmod('/var/spool/greyhole', 0777); // mkdir mode is affected by the umask, so we need to insure proper mode on that folder.
        chmod('/var/spool/greyhole/mem', 0777);
    }

    // If we have enough queued tasks (90% of $max_queued_tasks), let's not parse the log at this time, and get some work done.
    // Once we fall below that, we'll queue up to at most $max_queued_tasks new tasks, then get back to work.
    // This will effectively 'batch' large file operations to make sure the DB doesn't become a problem because of the number of rows,
    //   and this will allow the end-user to see real activity, other that new rows in greyhole.tasks...
    $query = "SELECT COUNT(*) FROM tasks";
    $num_rows = (int) DB::getFirstValue($query);
    $max_queued_tasks = Config::get(CONFIG_MAX_QUEUED_TASKS);
    if ($num_rows >= ($max_queued_tasks * 0.9)) {
        Log::restorePreviousAction();
        if (time() % 10 == 0) {
            Log::debug("  More than " . ($max_queued_tasks * 0.9) . " tasks queued... Won't queue any more at this time.");
        }
        return;
    }

    $new_tasks = 0;
    $last_line = FALSE;
    $act = FALSE;
    $close_tasks = array();
    while (TRUE) {
        $files = array();
        $last_filename = FALSE;
        $space_left_in_queue = $max_queued_tasks - $num_rows - $new_tasks;
        exec('find -L /var/spool/greyhole -type f -printf "%T@ %p\n" | sort -n 2> /dev/null | head -' . $space_left_in_queue, $files);
        if (count($files) == 0) {
            break;
        }

        if ($last_line === FALSE) {
            Log::debug("Processing Samba spool...");
        }
        
        foreach ($files as $file) {
            // Remove timestamp prefix from $file (%T@ above), to get the complete filename
            $file = explode(' ', $file);
            array_shift($file);
            $filename = implode(' ', $file);

            if ($last_filename) {
                unlink($last_filename);
            }

            $last_filename = $filename;

            $line = file_get_contents($filename);

            // Prevent insertion of unneeded duplicates
            if ($line === $last_line) {
                continue;
            }

            $line_ar = explode("\n", $line);

            $last_line = $line;

            // Close & fwrite logs are only processed when no more duplicates are found, so we'll execute this now that a non-duplicate line was found.
            if ($act === 'fwrite' || $act === 'close') {
                close_task($act, $share, $fd, $close_tasks);
            }

            $line = $line_ar;
            $act = array_shift($line);
            $share = array_shift($line);
            if ($act == 'mkdir') {
                // Just create the same folder on the 2 backup drives, to be able to get back empty folders, if we ever lose the LZ
                $dir_fullpath = get_share_landing_zone($share) . "/$line[0]";
                Log::debug("Directory created: $share/$line[0]");
                foreach (Config::get(CONFIG_METASTORE_BACKUPS) as $metastore_backup_drive) {
                    $backup_drive = str_replace('/.gh_metastore_backup', '', $metastore_backup_drive);
                    if (StoragePool::is_pool_drive($backup_drive)) {
                        gh_mkdir("$backup_drive/$share/$line[0]", $dir_fullpath);
                    }
                }
                continue;
            }
            $result = array_pop($line);
            if (string_starts_with($result, 'failed')) {
                Log::debug("Failed $act in $share/$line[0]. Skipping.");
                continue;
            }
            unset($fullpath);
            unset($fullpath_target);
            unset($fd);
            switch ($act) {
                case 'open':
                    $fullpath = array_shift($line);
                    $fd = array_shift($line);
                    $act = 'write';
                    break;
                case 'rmdir':
                case 'unlink':
                    $fullpath = array_shift($line);
                    break;
                case 'rename':
                    $fullpath = array_shift($line);
                    $fullpath_target = array_shift($line);
                    break;
                case 'fwrite':
                    $fd = array_shift($line);
                    break;
                case 'close':
                    $fd = array_shift($line);
                    break;
                default:
                    $act = FALSE;
            }
            if ($act === FALSE) {
                continue;
            }

            // Close & fwrite logs are only processed when no more duplicates are found, so we won't execute it just yet; we'll process it the next time we find a non-duplicate line.
            if ($act != 'close' && $act != 'fwrite') {
                if (isset($fd) && $fd == -1) {
                    continue;
                }
                if ($act != 'unlink' && $act != 'rmdir' && array_contains(ConfigHelper::$trash_share_names, $share)) { continue; }
                $new_tasks++;
                $query = "INSERT INTO tasks SET action = :action, share = :share, full_path = :full_path, additional_info = :additional_info, complete = :complete";
                $fullpath = isset($fullpath) ? clean_dir($fullpath) : NULL;
                $fullpath_target = isset($fullpath_target) ? clean_dir($fullpath_target) : (isset($fd) ? $fd : NULL);
                $params = array(
                    'action' => $act,
                    'share' => $share,
                    'full_path' => $fullpath,
                    'additional_info' => $fullpath_target,
                    'complete' => $act == 'write' ? 'no' : 'yes',
                );
                DB::insert($query, $params);
            }

            // If we have enough queued tasks ($max_queued_tasks), let's stop parsing the log, and get some work done.
            if ($num_rows+$new_tasks >= $max_queued_tasks) {
                Log::debug("  We now have more than $max_queued_tasks tasks queued... Will stop parsing for now.");
                break;
            }
        }
        if ($last_filename) {
            unlink($last_filename);
        }
        if ($num_rows+$new_tasks >= $max_queued_tasks) {
            break;
        }
    }

    // Close & fwrite logs are only processed when no more duplicates are found, so we'll execute this now that we're done parsing all spooled files.
    if ($act === 'fwrite' || $act === 'close') {
        close_task($act, $share, $fd, $close_tasks);
    }
    // We also need to 'execute' all close tasks, now that we're just all fwrite have been logged
    close_all_tasks($close_tasks);

    if ($new_tasks > 0) {
        Log::debug("Found $new_tasks new tasks in spool.");
    }

    Log::restorePreviousAction();
}

// See explanation in close_task() about armv5 VFS modules
$use_old_vfs = FALSE;
if (stripos($arch, 'armv5') !== FALSE) {
    $use_old_vfs = TRUE;
}

function close_task($act, $share, $fd, &$tasks) {
    if ($act === 'fwrite') {
        $query = "UPDATE tasks SET complete = 'written' WHERE complete = 'no' AND share = :share AND additional_info = :fd";
        DB::execute($query, array('share' => $share, 'fd' => $fd));
    }
    if ($act === 'close') {
        global $use_old_vfs;
        if ($use_old_vfs) {
            // armv5 VFS have not been recompiled to create fwrite spooled files; so for those, we process close tasks like we did before.
            $query = "UPDATE tasks SET additional_info = NULL, complete = 'yes' WHERE complete = 'no' AND share = :share AND additional_info = :fd";
            DB::execute($query, array('share' => $share, 'fd' => $fd));
        } else {
            // We will only close tasks at the very end, to make sure all fwrite tasks have been handled.
            // We need to do this because some fwrite spool file might apply to multiple write (open) tasks.
            // For example: writing into two files in the same share within the same second. See Greyhole VFS implementation for writes to see why.
            $last_id = DB::getFirstValue("SELECT MAX(id) FROM tasks");
            if ($last_id) {
                $task = (object) array(
                    'share' => $share,
                    'fd' => $fd,
                    'last_id' => $last_id,
                );
                $tasks[] = $task;
            }
        }
    }
}

function close_all_tasks($tasks) {
    foreach ($tasks as $task) {
        $share = $task->share;
        $fd = $task->fd;
        $last_id = $task->last_id;

        // We only want to handle real writes (complete = 'written'); if complete = 'no', that means the file was open for writing, but wasn't written to; we'll ignore those.

        $params = array('share' => $share, 'fd' => $fd, 'last_id' => $last_id);

        $query = "UPDATE tasks SET additional_info = NULL, complete = 'yes' WHERE complete = 'written' AND share = :share AND additional_info = :fd AND id <= :last_id";
        DB::execute($query, $params);

        // Remove write tasks that were not written to. But log them first.
        $query = "SELECT id, full_path FROM tasks WHERE complete = 'no' AND share = :share AND additional_info = :fd AND id <= :last_id";
        $rows = DB::getAll($query, $params);
        foreach ($rows as $row) {
            // Maybe the file is empty?
            $file_fullpath = get_share_landing_zone($share) . '/' . $row->full_path;
            $size = gh_filesize($file_fullpath);
            if ($size == 0) {
                $query = "UPDATE tasks SET additional_info = NULL, complete = 'yes' WHERE id = :task_id";
                DB::execute($query, array('task_id' => $row->id));
            } else {
                // Ignore
                Log::debug("File pointer to $row->full_path was closed without being written to. Ignoring.");
            }
        }

        $query = "DELETE FROM tasks WHERE complete = 'no' AND share = :share AND additional_info = :fd AND id <= :last_id";
        DB::execute($query, $params);
    }
}

// Cached df results
$last_df_time = 0;
$last_dfs = array();
function get_free_space_in_storage_pool_drives() {
    global $last_df_time, $last_dfs;
    if ($last_df_time > time() - Config::get(CONFIG_DF_CACHE_TIME)) {
        return $last_dfs;
    }
    $dfs = array();
    exec(ConfigHelper::$df_command, $responses);
    $responses_arr = array();
    foreach ($responses as $line) {
        if (preg_match("@\s+[0-9]+\s+([0-9]+)\s+([0-9]+)\s+[0-9]+%\s+(.+)$@", $line, $regs)) {
                $responses_arr[] = array((float) $regs[1], (float) $regs[2], $regs[3]);
        }
    }
    $responses = $responses_arr;
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (!StoragePool::is_pool_drive($sp_drive)) {
            continue;
        }
        $target_drive = '';
        for ($i=0; $i<count($responses); $i++) {
            $used_space = $responses[$i][0];
            $free_space = $responses[$i][1];
            $mount = $responses[$i][2];
            if (mb_strpos($sp_drive, $mount) === 0 && mb_strlen($mount) > mb_strlen($target_drive)) {
                $target_drive = $mount;
                $target_freespace = $free_space;
                $target_usedspace = $used_space;
            }
        }
        $dfs[$sp_drive]['free'] = $target_freespace;
        $dfs[$sp_drive]['used'] = $target_usedspace;
    }
    $last_df_time = time();
    $last_dfs = $dfs;
    return $dfs;
}

function order_target_drives($filesize_kb, $include_full_drives, $share, $path, $log_prefix='') {
    global $last_OOS_notification;

    foreach (SharesConfig::get($share, CONFIG_DRIVE_SELECTION_ALGORITHM) as $ds) {
        $algo = $ds->selection_algorithm;
        break;
    }

    $dfs = get_free_space_in_storage_pool_drives();

    $sorted_target_drives = array('available_space' => array(), 'used_space' => array());
    $last_resort_sorted_target_drives = array('available_space' => array(), 'used_space' => array());
    $full_drives = array();
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (!isset($dfs[$sp_drive])) {
            if (!is_dir($sp_drive)) {
                Log::error("The directory at $sp_drive doesn't exist. This drive will never be used!");
                if (SystemHelper::is_amahi()) {
                    Log::error("You should de-select, then re-select this partition in your Amahi dashboard (http://hda), in the Shares > Storage Pool page, to fix this problem.");
                } else {
                    Log::error("See the INSTALL file for instructions on how to prepare partitions to include in your storage pool.");
                }
            } else if (!file_exists("$sp_drive/.greyhole_used_this") && StoragePool::is_pool_drive($sp_drive)) {
                Log::error("Can't find how much free space is left on $sp_drive. This partition will never be used!");
                Log::error("Please report this using the 'Issues' tab found on https://github.com/gboudreau/Greyhole. You should include the following information in your ticket:");
                Log::error("===== Error report starts here =====");
                Log::error("Unknown free space for partition: $sp_drive");
                Log::error("df_command: " . ConfigHelper::$df_command);
                unset($responses);
                exec(ConfigHelper::$df_command, $responses);
                Log::error("Result of df_command: " . var_export($responses, TRUE));
                unset($responses);
                exec('df -k 2>&1', $responses);
                Log::error("Result of df -k: " . var_export($responses, TRUE));
                Log::error("===== Error report ends here =====");
            }
            continue;
        }
        if (!StoragePool::is_pool_drive($sp_drive)) {
            continue;
        }
        $free_space = $dfs[$sp_drive]['free'];
        $used_space = $dfs[$sp_drive]['used'];
        $minimum_free_space = (float) Config::get(CONFIG_MIN_FREE_SPACE_POOL_DRIVE, $sp_drive);
        $available_space = (float) $free_space - $minimum_free_space;
        if ($available_space <= $filesize_kb) {
            if ($free_space > $filesize_kb) {
                $last_resort_sorted_target_drives['available_space'][$sp_drive] = $available_space;
                $last_resort_sorted_target_drives['used_space'][$sp_drive] = $used_space;
            } else {
                $full_drives[$sp_drive] = $free_space;
            }
            continue;
        }
        $sorted_target_drives['available_space'][$sp_drive] = $available_space;
        $sorted_target_drives['used_space'][$sp_drive] = $used_space;
    }

    foreach (SharesConfig::get($share, CONFIG_DRIVE_SELECTION_ALGORITHM) as $ds) {
        $s = $sorted_target_drives;
        $l = $last_resort_sorted_target_drives;
        $ds->init($s, $l);
    }

    $sorted_target_drives = array();
    $last_resort_sorted_target_drives = array();
    $got_all_drives = FALSE;
    while (!$got_all_drives) {
        $num_empty_ds = 0;
        global $is_forced;
        foreach (SharesConfig::get($share, CONFIG_DRIVE_SELECTION_ALGORITHM) as $ds) {
            $is_forced = $ds->isForced();
            list($drives, $drives_last_resort) = $ds->draft();
            foreach ($drives as $sp_drive => $space) {
                $sorted_target_drives[$sp_drive] = $space;
            }
            foreach ($drives_last_resort as $sp_drive => $space) {
                $last_resort_sorted_target_drives[$sp_drive] = $space;
            }
            if (count($drives) == 0 && count($drives_last_resort) == 0) {
                $num_empty_ds++;
            }
        }
        if ($num_empty_ds == count(SharesConfig::get($share, CONFIG_DRIVE_SELECTION_ALGORITHM))) {
            // All DS are empty; exit.
            $got_all_drives = TRUE;
            break;
        }
    }
    
    // Email notification when all drives are over-capacity
    if (count($sorted_target_drives) == 0) {
        Log::warn("  Warning! All storage pool drives are over-capacity!");
        if (!isset($last_OOS_notification)) {
            $setting = Settings::get('last_OOS_notification');
            if ($setting === FALSE) {
                Log::warn("Received no rows when querying settings for 'last_OOS_notification'; expected one.");
                $setting = Settings::set('last_OOS_notification', 0);
            }
            $last_OOS_notification = $setting;
        }
        if ($last_OOS_notification < strtotime('-1 day')) {
            $email_to = Config::get(CONFIG_EMAIL_TO);

            Log::info("  Sending email notification to $email_to");

            $hostname = exec('hostname');
            $body = "This is an automated email from Greyhole.

It appears all the defined storage pool drives are over-capacity.
You probably want to do something about this!

";
            foreach ($last_resort_sorted_target_drives as $sp_drive => $free_space) {
                $minimum_free_space = (int) Config::get(CONFIG_MIN_FREE_SPACE_POOL_DRIVE, $sp_drive) / 1024 / 1024;
                $body .= "$sp_drive has " . number_format($free_space/1024/1024, 2) . " GB free; minimum specified in greyhole.conf: $minimum_free_space GB.\n";
            }
            mail($email_to, "Greyhole is out of space on $hostname!", $body);
            
            $last_OOS_notification = time();
            Settings::set('last_OOS_notification', $last_OOS_notification);
        }
    }
    
    if (Log::getLevel() >= Log::DEBUG) {
        if (count($sorted_target_drives) > 0) {
            $log = $log_prefix ."Drives with available space: ";
            foreach ($sorted_target_drives as $sp_drive => $space) {
                $log .= "$sp_drive (" . bytes_to_human($space*1024, FALSE) . " " . ($algo == 'most_available_space' ? 'avail' : 'used') . ") - ";
            }
            Log::debug(mb_substr($log, 0, mb_strlen($log)-2));
        }
        if (count($last_resort_sorted_target_drives) > 0) {
            $log = $log_prefix ."Drives with enough free space, but no available space: ";
            foreach ($last_resort_sorted_target_drives as $sp_drive => $space) {
                $log .= "$sp_drive (" . bytes_to_human($space*1024, FALSE) . " " . ($algo == 'most_available_space' ? 'avail' : 'used') . ") - ";
            }
            Log::debug(mb_substr($log, 0, mb_strlen($log)-2));
        }
        if (count($full_drives) > 0) {
            $log = $log_prefix ."Drives full: ";
            foreach ($full_drives as $sp_drive => $free_space) {
                $log .= "$sp_drive (" . bytes_to_human($free_space*1024, FALSE) . " free) - ";
            }
            Log::debug(mb_substr($log, 0, mb_strlen($log)-2));
        }
    }

    $sorted_target_drives = array_keys($sorted_target_drives);
    $last_resort_sorted_target_drives = array_keys($last_resort_sorted_target_drives);
    $full_drives = array_keys($full_drives);

    $drives = array_merge($sorted_target_drives, $last_resort_sorted_target_drives);
    if ($include_full_drives) {
        $drives = array_merge($drives, $full_drives);
    }

    $sticky_files = Config::get(CONFIG_STICKY_FILES);
    if (!empty($sticky_files)) {
        global $is_sticky;
        $is_sticky = FALSE;
        foreach ($sticky_files as $share_dir => $stick_into) {
            if (gh_wild_mb_strpos("$share/$path", $share_dir) === 0) {
                $is_sticky = TRUE;

                 $more_drives_needed = FALSE;
                if (count($stick_into) > 0) {
                    // Stick files into specific drives: $stick_into
                    // Let's check if those drives are listed in the config file!
                    foreach ($stick_into as $key => $stick_into_dir) {
                        if (!array_contains(Config::storagePoolDrives(), $stick_into_dir)) {
                            unset($stick_into[$key]);
                            $more_drives_needed = TRUE;
                        }
                    }
                }
                if (count($stick_into) == 0 || $more_drives_needed) {
                    if (string_contains($share_dir, '*')) {
                        // Contains a wildcard... In this case, we want each directory that match the wildcard to have it's own setting. Let's find this directory...
                        // For example, if $share_dir == 'Videos/Movies/*/*' and "$share/$path/" == "Videos/Movies/HD/La Vita e Bella/", we want to save a 'stick_into' setting for 'Videos/Movies/HD/La Vita e Bella/'
                        // Files in other subdirectories of Videos/Movies/HD/ could end up in other drives.
                        $needles = explode('*', $share_dir);
                        $sticky_dir = '';
                        $wild_part = "$share/$path/";
                        for ($i=0; $i<count($needles); $i++) {
                            $needle = $needles[$i];
                            if ($i == 0) {
                                $sticky_dir = $needle;
                                $wild_part = @str_replace_first($needle, '', $wild_part);
                            } else {
                                if ($needle == '') {
                                    $needle = '/';
                                }
                                $small_wild_part = mb_substr($wild_part, 0, mb_strpos($wild_part, $needle)+mb_strlen($needle));
                                $sticky_dir .= $small_wild_part;
                                $wild_part = str_replace_first($small_wild_part, '', $wild_part);
                            }
                        }
                        $sticky_dir = trim($sticky_dir, '/');
                    } else {
                        $sticky_dir = $share_dir;
                    }

                    // Stick files into any drives
                    $setting_name = sprintf('stick_into-%s', $sticky_dir);
                    $setting = Settings::get($setting_name, TRUE);
                    if ($setting) {
                        $stick_into = array_merge($stick_into, $setting);
                        // Let's check if those drives are listed in the config file!
                        $update_needed = FALSE;
                        foreach ($stick_into as $key => $stick_into_dir) {
                            if (!array_contains(Config::storagePoolDrives(), $stick_into_dir)) {
                                unset($stick_into[$key]);
                                $update_needed = TRUE;
                            }
                        }
                        if ($update_needed) {
                            $value = serialize($stick_into);
                            Settings::set($setting_name, $value);
                        }
                    } else {
                        $value = array_merge($stick_into, $drives);
                        Settings::set($setting_name, $value);
                    }
                }
                
                // Make sure the drives we want to use are not yet full and have available space
                $priority_drives = array();
                foreach ($stick_into as $stick_into_dir) {
                    if (array_contains(Config::storagePoolDrives(), $stick_into_dir)
                            && !array_contains($full_drives, $stick_into_dir)
                            && !array_contains($last_resort_sorted_target_drives, $stick_into_dir)) {
                        $priority_drives[] = $stick_into_dir;
                        unset($drives[array_search($stick_into_dir, $drives)]);
                    }
                }
                $drives = array_merge($priority_drives, $drives);
                Log::debug($log_prefix . "Reordered drives, per sticky_files config: " . implode(' - ', $drives));
                break;
            }
        }
    }

    return $drives;
}

function gh_fsck_reset_du($share, $full_path=null) {
    global $options;
    $options['du'] = TRUE;
    $params = array('share' => $share);
    if (empty($full_path)) {
        $query = "DELETE FROM du_stats WHERE share = :share";
    } else {
        $query = "DELETE FROM du_stats WHERE share = :share AND full_path LIKE :full_path";
        $params['full_path'] = "$full_path%";
    }
    DB::execute($query, $params);
}

function gh_fsck($path, $share, $storage_path = FALSE) {
    global $fsck_report, $options;

    $path = clean_dir($path);
    Log::debug("Entering $path");
    $fsck_report['landing_zone']['num_dirs']++;

    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (get_storage_volume_from_path($path) == $sp_drive && StoragePool::is_pool_drive($sp_drive)) {
            $dir_path = str_replace(clean_dir("$sp_drive/$share"), '', $path);
            $dir_in_lz = clean_dir(get_share_landing_zone($share) . "/$dir_path");
            if (!file_exists($dir_in_lz)) {
                Log::info("Re-creating $dir_in_lz from $path");
                gh_mkdir($dir_in_lz, $path);
            }
            break;
        }
    }


    $list = array();
    $handle = @opendir($path);
    if ($handle === FALSE) {
        Log::error("  Couldn't open $path to list content. Skipping...");
        return;
    }
    while (($filename = readdir($handle)) !== FALSE) {
        if ($filename != '.' && $filename != '..') {
            $full_path = "$path/$filename";
            $file_type = @filetype($full_path);
            if ($file_type === FALSE) {
                // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
                $file_type = @filetype(normalize_utf8_characters($full_path));
                if ($file_type !== FALSE) {
                    // Bingo!
                    $full_path = normalize_utf8_characters($full_path);
                    $path = normalize_utf8_characters($path);
                    $filename = normalize_utf8_characters($filename);
                }
            }
            if ($file_type == 'dir') {
                gh_fsck($full_path, $share, $storage_path);
            } else {
                gh_fsck_file($path, $filename, $file_type, 'landing_zone', $share, $storage_path);
                
                if (@$options['verify-checksums']) {
                    $count_md5 = get_count_md5();
                    if ($count_md5 > 1000) {
                        // 1000+ md5 tasks in the DB. Let's work on those a little before continuing.

                        // Make sure the MD5 worker threads are running.
                        check_md5_workers();

                        while ($count_md5 > 500) {
                            Log::debug("MD5 tasks pending: $count_md5");
                            $query = "SELECT id, action, share, full_path, additional_info, complete FROM tasks WHERE complete = 'yes' AND action = 'md5' ORDER BY id ASC LIMIT 1";
                            $task = DB::getFirst($query);
                            if ($task) {
                                gh_check_md5($task);
                            } else {
                                sleep(5);
                            }

                            $count_md5 = get_count_md5();
                        }
                    }
                }
            }
        }
    }
    closedir($handle);
}

function gh_fsck_metastore($root, $path, $share) {
    global $fsck_report;
    
    if (!is_dir("$root$path")) {
        // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
        $root = normalize_utf8_characters($root);
        $path = normalize_utf8_characters($path);
        if (!is_dir("$root$path")) {
            return;
        }
    }
    Log::debug("Entering metastore " . clean_dir($root . $path));

    $handle = opendir("$root$path");
    while (($filename = readdir($handle)) !== FALSE) {
        if ($filename != '.' && $filename != '..') {
            if (@is_dir("$root$path/$filename")) {
                $fsck_report['metastore']['num_dirs']++;
                gh_fsck_metastore($root, "$path/$filename", $share);
            } else {
                // Found a metafile
                $path_parts = explode('/', $path);
                array_shift($path_parts);
                $share = array_shift($path_parts);
                $landing_zone = get_share_landing_zone($share);
                $local_path = $landing_zone . '/' . implode('/', $path_parts);
                
                // If file exists in landing zone, we already fsck-ed it in gh_fsck(); let's not repeat ourselves, shall we?
                if (!file_exists("$local_path/$filename")) {
                    gh_fsck_file($local_path, $filename, FALSE, 'metastore', $share);
                }
            }
        }
    }
    closedir($handle);
}

function gh_fsck_file($path, $filename, $file_type, $source, $share, $storage_path = FALSE) {
    global $fsck_report, $options;
    $landing_zone = get_share_landing_zone($share);
    if($storage_path === FALSE) {
        $file_path = trim(mb_substr($path, mb_strlen($landing_zone)+1), '/');
    }else{
        $file_path = trim(mb_substr($path, mb_strlen("$storage_path/$share")+1), '/');
    }
    if ($file_type === FALSE) {
        clearstatcache();
        // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
        $file_type = @filetype(normalize_utf8_characters("$path/$filename"));
        if ($file_type !== FALSE) {
            // Bingo!
            $file_path = normalize_utf8_characters($file_path);
            $path = normalize_utf8_characters($path);
            $filename = normalize_utf8_characters($filename);
        }
    }
    if ($source == 'metastore') {
        $fsck_report['metastore']['num_files']++;
    }
    if ($file_type !== FALSE) {
        @$fsck_report['landing_zone']['num_files']++;
    }
    if ($file_type == 'file') {
        if($storage_path === FALSE) {
            // Let's just add a 'write' task for this file; if it's a duplicate of an already pending task, it won't be processed twice, since the simplify function will remove such duplicates.
            Log::info("$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
            $query = "INSERT INTO tasks SET action = 'write', share = :share, full_path = :full_path, complete = 'yes'";
            DB::insert($query, array('share' => $share, 'full_path' => clean_dir("$file_path/$filename")));
            return;
        }
    } else {
        if ($source == 'metastore') {
            if ($file_type == 'link' && !file_exists(readlink("$path/$filename"))) {
                // Link points to now gone copy; let's just remove it, and treat this as if the link was not there in the first place.
                unlink("$path/$filename");
                $file_type = FALSE;
            }
            if ($file_type === FALSE) {
                if (!Log::actionIs(ACTION_FSCK_FILE)) {
                    // Maybe this file was removed after fsck started, and thus shouldn't be re-created here!
                    // We'll queue this file fsck (to restore the symlink) for when all other file operations have been executed.
                    Log::debug("  Queuing a new fsck_file task for " . clean_dir("$share/$file_path/$filename"));
                    $query = "INSERT INTO tasks SET action = 'fsck_file', share = :share, full_path = :full_path, complete = 'idle', additional_info = :fsck_options";
                    $params = array(
                        'share' => $share,
                        'full_path' => empty($file_path) ? $filename : clean_dir("$file_path/$filename"),
                        'fsck_options' => @$options['all-fsck-options'],
                    );
                    DB::insert($query, $params);
                    return;
                }
            }
        }
    }
    
    if (get_metafile_data_filename($share, $file_path, $filename) === FALSE && get_metafile_data_filename($share, normalize_utf8_characters($file_path), normalize_utf8_characters($filename)) === FALSE) {
        $full_path = clean_dir("$path/$filename");

        // Check if this is a temporary file; if so, just delete it.
        if (is_temp_file($full_path)) {
            $fsck_report['temp_files'][] = $full_path;
            gh_recycle($full_path);
            return;
        }

        if ($storage_path !== FALSE) {
            if (@$options['find-orphans']) {
                Log::info("$full_path is an orphaned file; we'll proceed to find all copies and symlink this file appropriately.");
                $fsck_report['orphaned']['num_orphans']++;
            } else {
                Log::info("$full_path is an orphaned file, but we're not looking for orphans. For Greyhole to recognize this file, initiate a fsck with the --find-orphaned-files option.");
                return;
            }
        }
    }

    // Look for this file on all available drives
    $file_metafiles = array();
    $file_copies_inodes = get_file_inodes($share, $file_path, $filename, $file_metafiles);
    if (count($file_metafiles) == 0) {
        // If we found 0 file copies the first time, we normalize the file path (using NFC) and try again.
        // Ref: http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization
        $file_copies_inodes = get_file_inodes($share, normalize_utf8_characters($file_path), normalize_utf8_characters($filename), $file_metafiles);
        if (count($file_metafiles) > 0) {
            // Bingo!
            $file_path = normalize_utf8_characters($file_path);
            $filename = normalize_utf8_characters($filename);
        }
    }
    
    $num_ok = count($file_copies_inodes);
    if ($num_ok == 0 && count($file_metafiles) > 0) {
        // We found 1+ files, but none or them are on a defined storage drive; we can still use them as the source to create additional copies.
        $metadata = reset($file_metafiles);
        $original_file_path = $metadata->path;
    }

    foreach (get_metafiles($share, $file_path, $filename, TRUE) as $metafile_block) {
        foreach ($metafile_block as $metafile) {
            $inode_number = @gh_fileinode($metafile->path);
            $root_path = str_replace(clean_dir("/$share/$file_path/$filename"), '', $metafile->path);
            if ($root_path == $metafile->path) {
                // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
                $root_path = str_replace(normalize_utf8_characters(clean_dir("/$share/$file_path/$filename")), '', normalize_utf8_characters($metafile->path));
                if ($root_path == $metafile->path) {
                    Log::warn("Couldn't find root path for $metafile->path");
                }
                if ($inode_number !== FALSE && $metafile->state == 'OK') {
                    Log::debug("Found $metafile->path");
                }
            }

            // Sometimes, two paths will be almost the same, except for the UTF-8 normalization they use.
            // For those, we could end up with two entries in $file_metafiles - bad!
            // So we make sure we don't end up with duplicates like this:
            foreach ($file_metafiles as $k => $v) {
                if ($k == $metafile->path || normalize_utf8_characters($k) == normalize_utf8_characters($metafile->path)) {
                    $metafile->path = $v->path;
                    $metafile->state = $v->state;
                    unset($file_metafiles[$k]);
                    break;
                }
            }

            if (is_link($metafile->path)) {
                $link_target = readlink($metafile->path);
                if (array_contains($file_copies_inodes, $link_target)) {
                    // This link points to another file copy. Bad, bad!
                    Log::warn("Warning! Found a symlink in your storage pool: $metafile->path -> $link_target. Deleting.");
                    gh_recycle($metafile->path);
                }
                $inode_number = FALSE;
            }
            if ($inode_number === FALSE || !StoragePool::is_pool_drive($root_path)) {
                $metafile->state = 'Gone';
                $metafile->is_linked = FALSE;
                if (StoragePool::gone_ok($root_path)) {
                    // Let's not replace this copy yet...
                    $file_copies_inodes[$metafile->path] = $metafile->path;
                    $num_ok++;
                    $fsck_report['gone_ok']++;
                }
            } else if (is_dir($metafile->path)) {
                Log::debug("Found a directory that should be a file! Will try to remove it, if it's empty.");
                @rmdir($metafile->path);
                $metafile->state = 'Gone';
                $metafile->is_linked = FALSE;
                continue;
            } else {
                $metafile->state = 'OK';
                if (!isset($file_metafiles[$metafile->path])) {
                    $file_copies_inodes[$inode_number] = $metafile->path;
                    $num_ok++;
                }
            }
            $file_metafiles[clean_dir($metafile->path)] = $metafile;
        }
    }

    $num_copies_required = get_num_copies($share);
    if ($num_copies_required == -1) {
        Log::warn("Tried to fsck a share that is missing from greyhole.conf. Skipping.");
        return;
    }
    
    if (count($file_copies_inodes) > 0) {
        $found_linked_metafile = FALSE;
        foreach ($file_metafiles as $metafile) {
            if ($metafile->is_linked) {
                if (file_exists($metafile->path)) {
                    // Supposed to be the target of the symlink; but we need to make sure that's true!
                    $symlink_file_path = clean_dir(get_share_landing_zone($share) . "/$file_path/$filename");
                    $found_linked_metafile = @filetype($symlink_file_path) == 'link' && readlink($symlink_file_path) == clean_dir($metafile->path);
                    $expected_file_size = gh_filesize($metafile->path);
                    $original_file_path = $metafile->path;
                    break;
                } else {
                    $metafile->is_linked = FALSE;
                    $metafile->state = 'Gone';
                }
            }
        }
        // If no metafile is linked, link the 1st one (that is OK)
        if (!$found_linked_metafile) {
            foreach ($file_metafiles as $first_metafile) {
                $root_path = str_replace(clean_dir("/$share/$file_path/$filename"), '', $first_metafile->path);
                if ($first_metafile->state == 'OK' && StoragePool::is_pool_drive($root_path)) {
                    $first_metafile->is_linked = TRUE;
                    $expected_file_size = gh_filesize($first_metafile->path);
                    $original_file_path = $first_metafile->path;
                    break;
                }
            }
        }

        global $options;
        if (@$options['du']) {
            // Calculate du stats
            $du_path = trim(clean_dir("$file_path"), '/');
            do {
                $size = ($expected_file_size * $num_copies_required);

                if (empty($du_path)) {
                    $depth = 1;
                } else {
                    $chars_count = count_chars($du_path, 1);
                    if (!isset($chars_count[ord('/')])) {
                        $chars_count[ord('/')] = 0;
                    }
                    $depth = $chars_count[ord('/')] + 2;
                }

                $query = "INSERT INTO du_stats SET share = :share, full_path = :full_path, depth = :depth, size = :size ON DUPLICATE KEY UPDATE size = size + VALUES(size)";
                $params = array(
                    'share' => $share,
                    'full_path' => $du_path,
                    'depth' => $depth,
                    'size' => $size,
                );
                DB::insert($query, $params);

                $p = mb_strrpos($du_path, '/');
                if ($p) {
                    $du_path = mb_substr($du_path, 0, $p);
                } else if (!empty($du_path)) {
                    $last = TRUE;
                    $du_path = '';
                } else {
                    $last = FALSE;
                }
            } while (!empty($du_path) || $last);
        }
        
        // Check that all file copies have the same size
        foreach ($file_copies_inodes as $key => $real_full_path) {
            if (array_contains(array_keys($file_copies_inodes), $real_full_path)) {
                // That file isn't available atm, but it's OK.
                continue;
            }
            $file_size = gh_filesize($real_full_path);
            if ($file_size != $expected_file_size) {
                // Found a file with a different size than the original...
                // There might be a good reason. Let's look for one!
                if (real_file_is_locked($real_full_path) !== FALSE || real_file_is_locked($original_file_path) !== FALSE) {
                    // Write operation in progress
                    continue;
                }
                // A pending write transaction maybe?
                parse_samba_spool();
                $query = "SELECT * FROM tasks WHERE action = 'write' AND share = :share AND full_path = :full_path";
                $task = DB::getFirst($query, array('share' => $share, 'full_path' => "$file_path/$filename"));
                if ($task) {
                    // Pending write task
                    continue;
                }
                // Found no good reason!

                if ($file_size === FALSE) {
                    // Empty file; just delete it.
                    Log::warn("  An empty file copy was found: $real_full_path is 0 bytes. Original: $original_file_path is " . number_format($expected_file_size) . " bytes. This empty copy will be deleted.");
                    unlink($real_full_path);
                } else {
                    Log::warn("  A file copy with a different file size than the original was found: $real_full_path is " . number_format($file_size) . " bytes. Original: $original_file_path is " . number_format($expected_file_size) . " bytes.");
                    gh_recycle($real_full_path);
                    $fsck_report['wrong_file_size'][clean_dir($real_full_path)] = array($file_size, $expected_file_size, $original_file_path);
                }
                // Will not count that copy as a valid copy!
                unset($file_copies_inodes[$key]);
                unset($file_metafiles[clean_dir($real_full_path)]);
            }
        }
    }

    if (count($file_copies_inodes) == $num_copies_required) {
        // It's okay if the file isn't a symlink so long as we're looking at a storage volume path and not a share path
        if (!$found_linked_metafile || ($file_type != 'link' && $storage_path === FALSE)) {
            // Re-create symlink...
            if (!$found_linked_metafile) {
                // ... the old one points to a drive that was replaced
                Log::info('  Symlink target moved. Updating symlink.');
                $fsck_report['symlink_target_moved']++;
            } else {
                // ... it was missing
                Log::info('  Symlink was missing. Creating new symlink.');
            }
            foreach ($file_metafiles as $key => $metafile) {
                if ($metafile->is_linked) {
                    gh_fsck_update_symlink($metafile->path, "$landing_zone/$file_path/$filename", $share, $file_path, $filename);
                    break;
                }
            }
            save_metafiles($share, $file_path, $filename, $file_metafiles);
        }
    } else if (count($file_copies_inodes) == 0 && !isset($original_file_path)) {
        Log::warn('  WARNING! No copies of this file are available in the Greyhole storage pool. ' . (is_link("$landing_zone/$file_path/$filename") ? 'Deleting from share.' : (gh_is_file("$landing_zone/$file_path/$filename") ? 'Did you copy that file there without using your Samba shares? (If you did, don\'t do that in the future.)' : '')));
        if ($source == 'metastore' || get_metafile_data_filename($share, $file_path, $filename) !== FALSE) {
            $fsck_report['no_copies_found_files'][clean_dir("$share/$file_path/$filename")] = TRUE;
        }
        if (is_link("$landing_zone/$file_path/$filename")) {
            gh_recycle("$landing_zone/$file_path/$filename");
        } else if (gh_is_file("$landing_zone/$file_path/$filename")) {
            Log::info("$share/$file_path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
            $query = "INSERT INTO tasks SET action = 'write', share = :share, full_path = :full_path, complete = 'yes'";
            $params = array(
                'share' => $share,
                'full_path' => empty($file_path) ? $filename : clean_dir("$file_path/$filename"),
            );
            DB::insert($query, $params);
        }
        if (@$options['del-orphaned-metadata']) {
            remove_metafiles($share, $file_path, $filename);
        } else {
            save_metafiles($share, $file_path, $filename, $file_metafiles);
        }
    } else if (count($file_copies_inodes) < $num_copies_required && $num_copies_required > 0) {
        // Create new copies
        Log::info("  Missing file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will create more copies using $original_file_path");
        if (isset($fsck_report['missing_copies'])) {
            $fsck_report['missing_copies']++;
        }
        clearstatcache(); $filesize = gh_filesize($original_file_path);
        $file_metafiles = create_metafiles($share, "$file_path/$filename", $num_copies_required, $filesize, $file_metafiles);

        // Re-copy the file everywhere, and re-create the symlink
        $symlink_created = FALSE;
        $num_copies_current = 1; # the source file
        global $going_drive;
        if (!empty($going_drive)) {
            // Let's not count the source file here, since it will be gone soon!
            $num_copies_current = 0;
        }
        foreach ($file_metafiles as $key => $metafile) {
            if ($original_file_path != $metafile->path) {
                if ($num_copies_current >= $num_copies_required) {
                    $metafile->state = 'Gone';
                    $file_metafiles[$key] = $metafile;
                    continue;
                }

                list($metafile_dir_path, $metafile_filename) = explode_full_path($metafile->path);

                if ($metafile->state == 'Gone') {
                    foreach (Config::storagePoolDrives() as $sp_drive) {
                        if (get_storage_volume_from_path($metafile_dir_path) == $sp_drive && StoragePool::is_pool_drive($sp_drive)) {
                            $metafile->state = 'Pending';
                            $file_metafiles[$key] = $metafile;
                            break;
                        }
                    }
                }

                if ($metafile->state != 'Gone') {
                    $root_path = str_replace(clean_dir("/$share/$file_path"), '', $metafile_dir_path);
                    list($original_path, $metafile_filename) = explode_full_path(get_share_landing_zone($share) . "/$file_path");
                    if (!gh_mkdir($metafile_dir_path, $original_path)) {
                        $metafile->state = 'Gone';
                        $file_metafiles[$key] = $metafile;
                        continue;
                    }
                }

                if (!is_dir($metafile_dir_path) || $metafile->state == 'Gone') {
                    if ($metafile->state != 'Gone') {
                        // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
                        if (is_dir(normalize_utf8_characters($metafile_dir_path))) {
                            // Bingo!
                            $metafile_dir_path = normalize_utf8_characters($metafile_dir_path);
                            $metafile->path = normalize_utf8_characters($metafile->path);
                            $file_metafiles[$key] = $metafile;
                        } else {
                            continue;
                        }
                    }
                }

                if ($metafile->state == 'Pending') {
                    if (gh_copy_file($original_file_path, $metafile->path)) {
                        $metafile->state = 'OK';
                        $num_copies_current++;
                    } else {
                        if ($metafile->is_linked) {
                            $metafile->is_linked = FALSE;
                        }
                        $metafile->state = 'Gone';
                    }
                    $file_metafiles[$key] = $metafile;
                }
            }
            if ($original_file_path == $metafile->path || $metafile->is_linked) {
                if (!empty($going_drive) && get_storage_volume_from_path($original_file_path) == $going_drive) {
                    $metafile->is_linked = FALSE;
                    $metafile->state = 'Gone';
                    $file_metafiles[$key] = $metafile;
                    continue;
                }
                if ($symlink_created /* already */) {
                    $metafile->is_linked = FALSE;
                    $file_metafiles[$key] = $metafile;
                    continue;
                }
                
                gh_fsck_update_symlink($metafile->path, "$landing_zone/$file_path/$filename", $share, $file_path, $filename);
                $symlink_created = TRUE;
            }
        }
        if (!$symlink_created) {
            foreach ($file_metafiles as $key => $metafile) {
                if ($metafile->state == 'OK') {
                    $metafile->is_linked = TRUE;
                    $file_metafiles[$key] = $metafile;
                    gh_fsck_update_symlink($metafile->path, "$landing_zone/$file_path/$filename", $share, $file_path, $filename);
                    break;
                }
            }
        }
        save_metafiles($share, $file_path, $filename, $file_metafiles);
    } else {
        # Let's not assume that files on missing drives are really there... Removing files here could be dangerous!
        foreach ($file_copies_inodes as $inode => $path) {
            if (string_starts_with($inode, '/')) {
                unset($file_copies_inodes[$inode]);
            }
        }
        if (count($file_copies_inodes) > $num_copies_required) {
            Log::info("  Too many file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will try to remove some.");
            if (file_is_locked($share, "$file_path/$filename") !== FALSE) {
                Log::info("  File is locked. Will not remove copies at this time. The next fsck will try to remove copies again.");
                return;
            }
            $fsck_report['too_many_copies']++;
        
            $local_target_drives = array_values(order_target_drives(0, TRUE, $share, $file_path));

            // The drives that are NOT returned by order_target_drives(), but have a file copy, should be removed first
            $gone_drives = array();
            foreach (Config::storagePoolDrives() as $sp_drive) {
                $file = clean_dir("$sp_drive/$share/$file_path/$filename");
                if (!array_contains($local_target_drives, $sp_drive) && file_exists($file)) {
                    $gone_drives[] = $sp_drive;
                    $local_target_drives[] = $sp_drive;
                }
            }
            if (!empty($gone_drives)) {
                Log::debug("Drives that shouldn't be used anymore: " . implode(' - ', $gone_drives));
            }

            while (count($file_copies_inodes) > $num_copies_required && !empty($local_target_drives)) {
                $sp_drive = array_pop($local_target_drives);
                $key = clean_dir("$sp_drive/$share/$file_path/$filename");
                Log::debug("  Looking for copy at $key");
                if (isset($file_metafiles[$key]) || gh_file_exists($key)) {
                    if (isset($file_metafiles[$key])) {
                        $metafile = $file_metafiles[$key];
                    }
                    if (gh_file_exists($key) || $metafile->state == 'OK') {
                        Log::debug("    Found file copy at $key, or metadata file is marked OK.");
                        if (real_file_is_locked($key) !== FALSE) {
                            Log::debug("    File copy is locked. Won't remove it.");
                            continue;
                        }
                        $fsck_report['too_many_files'][] = $key;
                        Log::debug("    Removing copy at $key");
                        unset($file_copies_inodes[gh_fileinode($key)]);
                        gh_recycle($key);
                        if (isset($file_metafiles[$key])) {
                            unset($file_metafiles[$key]);
                        }
                        $num_ok--;
                    }
                }
            }

            // If no metafile is linked, link the 1st one
            $found_linked_metafile = FALSE;
            foreach ($file_metafiles as $key => $metafile) {
                if ($metafile->is_linked) {
                    $found_linked_metafile = TRUE;
                    break;
                }
            }
            if (!$found_linked_metafile) {
                $metafile = reset($file_metafiles);
                gh_fsck_update_symlink($metafile->path, "$landing_zone/$file_path/$filename", $share, $file_path, $filename);
                reset($file_metafiles)->is_linked = TRUE;
            }

            save_metafiles($share, $file_path, $filename, $file_metafiles);
        }
    }
    
    // Queue all file copies checksum calculations, if --checksums was specified
    if (@$options['verify-checksums']) {
        foreach (get_metafiles($share, $file_path, $filename, TRUE) as $metafile_block) {
            foreach ($metafile_block as $metafile) {
                if ($metafile->state != 'OK') { continue; }
                $inode_number = @gh_fileinode($metafile->path);
                if ($inode_number !== FALSE) {
                    // Let's calculate this file's MD5 checksum to validate that all copies are valid.
                    $query = "INSERT INTO tasks SET action = 'md5', share = :share, full_path = :full_path, additional_info = :additional_info, complete = 'no'";
                    $params = array(
                        'share' => $share,
                        'full_path' => clean_dir("$file_path/$filename"),
                        'additional_info' => $metafile->path
                    );
                    DB::insert($query, $params);
                }
            }
        }
    }
}

function gh_fsck_update_symlink($target, $symlink, $share, $file_path, $filename) {
    clearstatcache();
    if (!file_exists($symlink)) {
        Log::debug("  Missing symlink... A pending unlink transaction maybe?");
        parse_samba_spool();
        $query = "SELECT * FROM tasks WHERE action = 'unlink' AND share = :share AND full_path = :full_path";
        $params = array(
            'share' => $share,
            'full_path' => trim("$file_path/$filename", '/'),
        );
        $task = DB::getFirst($query, $params);
        if ($task) {
            Log::debug("    Indeed! Pending unlink task found. Will not re-create this symlink.");
            return;
        }
        Log::debug("    No... Found no good reason for the symlink to be missing! Let's re-create it.");
    }
    
    Log::debug("  Updating symlink at $symlink to point to $target");
    gh_recycle($symlink);
    gh_mkdir(dirname($symlink), dirname($target));
    gh_symlink($target, $symlink);
}

function initialize_fsck_report($what) {
    global $fsck_report;
    $fsck_report = array();
    $fsck_report['start'] = time();
    $fsck_report['what'] = $what;
    $fsck_report['metastore'] = array();
    $fsck_report['metastore']['num_dirs'] = 0;
    $fsck_report['metastore']['num_files'] = 0;
    $fsck_report['orphaned']['num_orphans'] = 0;
    $fsck_report['landing_zone'] = array();
    $fsck_report['landing_zone']['num_dirs'] = 0;
    $fsck_report['landing_zone']['num_files'] = 0;
    $fsck_report['no_copies_found_files'] = array();
    $fsck_report['symlink_target_moved'] = 0;
    $fsck_report['too_many_copies'] = 0;
    $fsck_report['too_many_files'] = array();
    $fsck_report['missing_copies'] = 0;
    $fsck_report['wrong_file_size'] = array();
    $fsck_report['temp_files'] = array();
    $fsck_report['gone_ok'] = 0;
}

function get_fsck_report() {
    global $fsck_report, $options;
    
    $fsck_report['end'] = time();
    
    $displayable_duration = duration_to_human($fsck_report['end'] - $fsck_report['start']);
    
    $report = "fsck report
-----------
Scanned directory: " . $fsck_report['what'] . "

Started:  " . date('Y-m-d H:i:s', $fsck_report['start']) . "
Ended:    " . date('Y-m-d H:i:s', $fsck_report['end']) . "
Duration: $displayable_duration

Metadata Store:
  Found " . number_format($fsck_report['metastore']['num_dirs']) . " directories
  Found " . number_format($fsck_report['metastore']['num_files']) . " files

Landing Zone (shares):
  Found " . number_format($fsck_report['landing_zone']['num_dirs']) . " directories
  Found " . number_format($fsck_report['landing_zone']['num_files']) . " files
  Found " . number_format($fsck_report['orphaned']['num_orphans']) . " orphans

Trash size:\n";

    foreach (Config::storagePoolDrives() as $sp_drive) {
        $trash_path = clean_dir("$sp_drive/.gh_trash");
        if (is_dir($trash_path)) {
            $report .= "  $trash_path = " . trim(exec("du -sh " . escapeshellarg($trash_path) . " | awk '{print $1}'"))."\n";
        } else if (!file_exists($sp_drive)) {
            $report .= "  $sp_drive = N/A\n";
        } else {
            $report .= "  $trash_path = empty\n";
        }
    }

    // Errors
    if (empty($fsck_report['no_copies_found_files']) && count($fsck_report['wrong_file_size']) == 0) {
        $report .= "\nNo problems found.\n\n";
    } else {
        $report .= "\nProblems:\n";

        if (!empty($fsck_report['no_copies_found_files'])) {
            ksort($fsck_report['no_copies_found_files']);
            $report .= "  Found " . count($fsck_report['no_copies_found_files']) . " files in the metadata store for which no file copies were found.\n";
            if (@$options['del-orphaned-metadata']) {
                $report .= "    Those metadata files have been deleted, since you used the --delete-orphaned-metadata option. They will not re-appear in the future.\n";
            } else {
                $report .= "    Those files were removed from the Landing Zone. (i.e. those files are now gone!) They will re-appear in your shares if a copy re-appear and fsck is run.\n";
                $report .= "    If you don't want to see those files listed here each time fsck runs, delete the corresponding files from the metadata store using \"greyhole --delete-metadata='<path>'\", where <path> is one of the value listed below.\n";
            }
              $report .= "  Files with no copies:\n";
            $report .= "    " . implode("\n    ", array_keys($fsck_report['no_copies_found_files'])) . "\n\n";
        }

        if (count($fsck_report['wrong_file_size']) > 0) {
            $report .= "  Found " . count($fsck_report['wrong_file_size']) . " file copies with the wrong file size. Those files don't have the same file size as the original files available on your shares. The invalid copies have been moved into the trash.\n";
            foreach ($fsck_report['wrong_file_size'] as $real_file_path => $info_array) {
                $report .= "    $real_file_path is " . number_format($info_array[0]) . " bytes; should be " . number_format($info_array[1]) . " bytes.\n";
            }
            $report .= "\n\n";
        }
    }

    // Warnings
    if ($fsck_report['too_many_copies'] == 0 && $fsck_report['symlink_target_moved'] == 0 && count($fsck_report['temp_files']) == 0 && $fsck_report['gone_ok'] == 0) {
        // Nothing to say...
    } else {
        $report .= "Notices:\n";

        if ($fsck_report['too_many_copies'] > 0) {
            $fsck_report['too_many_files'] = array_unique($fsck_report['too_many_files']);
        
            $report .= "  Found " . $fsck_report['too_many_copies'] . " files for which there was too many file copies. Deleted (or moved in trash) files:\n";
            $report .= "    " . implode("\n    ", $fsck_report['too_many_files']) . "\n\n";
        }

        if ($fsck_report['symlink_target_moved'] > 0) {
            $report .= "  Found " . $fsck_report['symlink_target_moved'] . " files in the Landing Zone that were pointing to a now gone copy.
    Those symlinks were updated to point to the new location of those file copies.\n\n";
        }

        if (count($fsck_report['temp_files']) > 0) {
            $report .= "  Found " . count($fsck_report['temp_files']) . " temporary files, which are leftovers of interrupted Greyhole executions. The following temporary files were deleted (or moved into the trash):\n";
            $report .= "    " . implode("\n    ", $fsck_report['temp_files']) . "\n\n";
        }
    
        if ($fsck_report['gone_ok'] > 0) {
            $report .= "  Found " . $fsck_report['gone_ok'] . " missing files that are in a storage pool drive marked Temporarily-Gone.
  If this drive is gone for good, you should execute the following command, and remove the drive from your configuration file:
    greyhole --gone=path
  where path is one of:\n";
            $report .= "    " . implode("\n    ", array_keys(StoragePool::get_gone_ok_drives())) . "\n\n";
        }
    }

    return $report;
}

function gh_recycle($real_path, $file_was_modified=FALSE) {
    $is_symlink = FALSE;
    clearstatcache();
    if (is_link($real_path)) {
        $is_symlink = TRUE;
    } else if (!file_exists($real_path)) {
        return TRUE;
    }

    $should_move_to_trash = FALSE;
    if (!$is_symlink) {
        $share_options = get_share_options_from_full_path($real_path);
        if ($share_options !== FALSE) {
            $full_path = trim($share_options['name'] . "/" . str_replace($share_options[CONFIG_LANDING_ZONE], '', $real_path), '/');
            $share = $share_options['name'];
        } else {
            $storage_volume = get_storage_volume_from_path($real_path);
            foreach (Config::storagePoolDrives() as $sp_drive) {
                if ($sp_drive == $storage_volume) {
                    $trash_path = "$sp_drive/.gh_trash";
                    $full_path = trim(substr($real_path, strlen($sp_drive)), '/');
                    break;
                }
            }

            $share = mb_substr($full_path, 0, mb_strpos($full_path, '/'));

            if ($file_was_modified) {
                $should_move_to_trash = SharesConfig::get($share, CONFIG_MODIFIED_MOVES_TO_TRASH);
            } else {
                $should_move_to_trash = SharesConfig::get($share, CONFIG_DELETE_MOVES_TO_TRASH);
            }
        }
    }
    
    if ($should_move_to_trash) {
        // Move to trash
        if (!isset($trash_path)) {
            Log::warn("  Warning! Can't find trash for $real_path. Won't delete this file!");
            return FALSE;
        }
        
        $target_path = clean_dir("$trash_path/$full_path");

        list($path, $filename) = explode_full_path($target_path);
        
        list($original_path, $filename) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
        
        if (@gh_is_file($path)) {
            unlink($path);
        }
        
        $dir_infos = (object) array(
            'fileowner' => 0,
            'filegroup' => 0,
            'fileperms' => (int) base_convert("0777", 8, 10)
        );
        gh_mkdir($path, $dir_infos);

        if (@is_dir($target_path)) {
            exec("rm -rf " . escapeshellarg($target_path));
        }
        if (@gh_rename($real_path, $target_path)) {
            Log::debug("  Moved copy from $real_path to trash: $target_path");
            
            // Create a symlink in the Greyhole Trash share, to allow the user to remove this file using that share
            create_trash_share_symlink($target_path, $trash_path);
            return TRUE;
        }
    } else {
        if (@unlink($real_path)) {
            if (!$is_symlink) {
                Log::debug("  Deleted copy at $real_path");
            }
            return TRUE;
        }
    }
    return FALSE;
}

function get_metastores_from_storage_volume($storage_volume) {
    $volume_metastores = array();
    foreach (get_metastores() as $metastore) {
        if (get_storage_volume_from_path($metastore) == $storage_volume) {
            $volume_metastores[] = $metastore;
        }
    }
    return $volume_metastores;
}

function get_metastores($use_cache=TRUE) {
    global $global_metastores;
    if (!isset($global_metastores) || !$use_cache) {
        $metastores = array();
        foreach (Config::storagePoolDrives() as $sp_drive) {
            if (StoragePool::is_pool_drive($sp_drive)) {
                $metastores[] = "$sp_drive/.gh_metastore";
            }
        }
        foreach (Config::get(CONFIG_METASTORE_BACKUPS) as $metastore_backup_drive) {
            if (StoragePool::is_pool_drive(str_replace('/.gh_metastore_backup', '', $metastore_backup_drive))) {
                $metastores[] = $metastore_backup_drive;
            }
        }
        $global_metastores = $metastores;
    }
    return $global_metastores;
}

function get_share_options_from_full_path($full_path) {
    $landing_zone = '';
    $share = FALSE;
    foreach (SharesConfig::getShares() as $share_name => $share_options) {
        if (string_starts_with($full_path, $share_options[CONFIG_LANDING_ZONE]) && mb_strlen($share_options[CONFIG_LANDING_ZONE]) > mb_strlen($landing_zone)) {
            $landing_zone = $share_options[CONFIG_LANDING_ZONE];
            $share = $share_options;
        }
    }
    return $share;
}

function get_storage_volume_from_path($full_path) {
    $storage_volume = FALSE;
    $longest_path_found = 0;
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (string_starts_with($full_path, $sp_drive) && mb_strlen($sp_drive) > $longest_path_found) {
            $storage_volume = $sp_drive;
            $longest_path_found = mb_strlen($sp_drive);
        } 
    }
    return $storage_volume;
}

function get_share_options_from_storage_volume($full_path,$storage_volume) {
    $landing_zone = '';
    $share = FALSE;
    foreach (SharesConfig::getShares() as $share_name => $share_options) {
        $metastore = get_metastore_from_path($full_path);
        if($metastore !== FALSE) {
            if (string_starts_with($full_path, "$metastore/$share_name") && mb_strlen($share_options[CONFIG_LANDING_ZONE]) > mb_strlen($landing_zone)) {
                $landing_zone = $share_options[CONFIG_LANDING_ZONE];
                $share = $share_options;
            }
        }else{
            if (string_starts_with($full_path, "$storage_volume/$share_name") && mb_strlen($share_options[CONFIG_LANDING_ZONE]) > mb_strlen($landing_zone)) {
                $landing_zone = $share_options[CONFIG_LANDING_ZONE];
                $share = $share_options;
            }
        }
    }
    return $share;
}

function get_metastore_from_path($path) {
    $metastore_path = FALSE;
    foreach(get_metastores() as $metastore) {
        if (string_starts_with($path, $metastore)) {
            $metastore_path = $metastore;
            break;
        }    
    }
    return $metastore_path;
}

function gh_get_file_infos($real_path) {
    if ($real_path == null || !file_exists($real_path)) {
        return (object) array(
            'fileowner' => 0,
            'filegroup' => 0,
            'fileperms' => (int) base_convert("0777", 8, 10),
            'filemtime' => time()
        );
    }
    if (is_link($real_path)) {
        $real_path = readlink($real_path);
    }
    return (object) array(
        'fileowner' => (int) gh_fileowner($real_path),
        'filegroup' => (int) gh_filegroup($real_path),
        'fileperms' => (int) base_convert(gh_fileperms($real_path), 8, 10),
        'filemtime' => filemtime($real_path),
    );
}

function gh_get_dir_perms($directory) {
    return (int) base_convert(gh_fileperms($directory), 8, 10);
}

function gh_balance() {
    global $is_sticky;

    // Start with shares that have sticky files, so that subsequent shares will be used to try to balance what moving files into stick_into drives could debalance...
    // Then start with the shares for which we keep the most # copies;
    // That way, if the new drive fails soon, it won't take with it files for which we only have one copy!
    $sorted_shares_options = SharesConfig::getShares();
    unset($sorted_shares_options[CONFIG_TRASH_SHARE]);
    uasort($sorted_shares_options, 'compare_share_balance');
    $skip_stickies = FALSE;
    foreach ($sorted_shares_options as $share_name => $share_options) {
        if ($share_options[CONFIG_NUM_COPIES] == count(Config::storagePoolDrives())) {
            // Files are everywhere; won't be able to use that share to balance available space!
            continue;
        }
        
        if ($skip_stickies && is_share_sticky($share_name)) {
            Log::debug("Skipping sticky share $share_name.");
            continue;
        }

         Log::debug("Balancing share: $share_name");

        // Move files from the drive with the less available space to the drive with the most available space.
        $sorted_pool_drives = sort_storage_drives_available_space();
        $pool_drives_avail_space = array();
        foreach ($sorted_pool_drives as $available_space => $drive) {
            $pool_drives_avail_space[$drive] = $available_space;
        }
        $num_total_drives = count($sorted_pool_drives);
        
        $balance_direction_asc = array();
        foreach ($sorted_pool_drives as $available_space => $drive) {
            $target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
            $balance_direction_asc[$drive] = $pool_drives_avail_space[$drive] < $target_avail_space;
        }

        foreach ($sorted_pool_drives as $source_drive) {
            $target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
            Log::debug("Balancing storage pool drive: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available, target: ". bytes_to_human($target_avail_space*1024, FALSE) .")");

            // Files candidate to get moved
            $files = array();
            if (is_dir("$source_drive/$share_name")) {
                exec("find ". escapeshellarg("$source_drive/$share_name") ." -type f -size +10M", $files);
            }
            Log::debug("Found ". count($files) ." files that can be moved.");
            
            // Repeat until all drives' available space is balanced.
            foreach ($files as $file) {
                // Let's not try to move locked files!
                if (real_file_is_locked($file) !== FALSE) {
                    Log::debug("  File $file is locked by another process. Skipping.");
                    continue;
                }

                $filesize = gh_filesize($file)/1024; // KB

                $full_path = mb_substr($file, mb_strlen("$source_drive/$share_name/"));
                list($path, $filename) = explode_full_path($full_path);
                Log::debug("  Working on file: $share_name/$full_path (". bytes_to_human($filesize*1024, FALSE) .")");

                // $is_sticky and $is_forced are set in order_target_drives(), based on $share_name & $path
                $sp_drives = order_target_drives($filesize, FALSE, $share_name, $path, '  ');

                unset($sp_drive);
                if ($is_sticky) {
                    if (count($sp_drives) == $num_total_drives - 1 && !array_contains($sp_drives, $source_drive)) {
                        // Only drive full is the source drive. Let's move files away from there!
                    } else if (count($sp_drives) < $num_total_drives) {
                        $skip_stickies = TRUE;
                        Log::debug("  Some drives are full. Skipping sticky shares until all drives have some free space.");
                        break;
                    }
                    
                    $sticky_drives = array_slice($sp_drives, 0, get_num_copies($share_name));
                    if (array_contains($sticky_drives, $source_drive)) {
                        // Source drive is a stick_into drive; let's not move that file!
                        Log::debug("  Source is sticky. Skipping.");
                        continue;
                    }
                    $already_stuck_copies = 0;
                    foreach ($sticky_drives as $drive) {
                        if (file_exists("$drive/$share_name/$full_path")) {
                            $already_stuck_copies++;
                        } else {
                            $sp_drive = $drive;
                        }
                    }
                } else {
                    while (count($sp_drives) > 0) {
                        $drive = array_shift($sp_drives);
                        if (!file_exists("$drive/$share_name/$full_path")) {
                            $sp_drive = $drive;
                            break;
                        }
                    }
                }
                
                if (!isset($sp_drive)) {
                    // Can't find a drive that doesn't have this file; skipping.
                    if ($is_sticky) {
                        Log::debug("  Sticky file is already where it should be. Skipping.");
                    }
                    continue;
                }

                Log::debug("  Target drive: $sp_drive (". bytes_to_human($pool_drives_avail_space[$sp_drive]*1024, FALSE) ." available)");

                if ($is_sticky) {
                    Log::debug("  Moving sticky file, even if that means it won't help balancing available space.");
                } else if ($pool_drives_avail_space[$source_drive]+$filesize+1*1024*1024 /*1GB*/ > $pool_drives_avail_space[$sp_drive]-$filesize
                        || $pool_drives_avail_space[$source_drive]+$filesize > $target_avail_space
                        || ($balance_direction_asc[$sp_drive] && $pool_drives_avail_space[$sp_drive] > $target_avail_space)
                        || (!$balance_direction_asc[$sp_drive] && $pool_drives_avail_space[$sp_drive] < $target_avail_space)) {
                    Log::debug("  Moving this file wouldn't help balancing available space. Skipping.");
                    #Log::debug("    Reason 1: " . var_export($pool_drives_avail_space[$source_drive]+$filesize+1*1024*1024 /*1GB*/ > $pool_drives_avail_space[$sp_drive]-$filesize, TRUE));
                    #Log::debug("    Reason 2: " . var_export($pool_drives_avail_space[$source_drive]+$filesize > $target_avail_space, TRUE));
                    #Log::debug("    Reason 3: " . var_export($balance_direction_asc[$sp_drive] && $pool_drives_avail_space[$sp_drive] > $target_avail_space, TRUE));
                    #Log::debug("    Reason 4: " . var_export(!$balance_direction_asc[$sp_drive] && $pool_drives_avail_space[$sp_drive] < $target_avail_space, TRUE));
                    #Log::debug("    pool_drives_avail_space[source]+filesize+1GB = " . ($pool_drives_avail_space[$source_drive]+$filesize+1*1024*1024));
                    #Log::debug("    pool_drives_avail_space[source]+filesize = " . ($pool_drives_avail_space[$source_drive]+$filesize));
                    #Log::debug("    pool_drives_avail_space[target_drive] = " . ($pool_drives_avail_space[$sp_drive]));
                    #Log::debug("    pool_drives_avail_space[target_drive]-filesize = " . ($pool_drives_avail_space[$sp_drive]-$filesize));
                    #Log::debug("    target_avail_space = " . ($target_avail_space));
                    #Log::debug("    balance_direction_asc[target_drive] = " . var_export($balance_direction_asc[$sp_drive], TRUE));
                    continue;
                }

                // Make sure the parent directory exists, before we try moving something there...
                $original_path = clean_dir("$source_drive/$share_name/$path");
                list($target_path, $filename) = explode_full_path("$sp_drive/$share_name/$full_path");
                gh_mkdir($target_path, $original_path);

                // Move the file
                $temp_path = get_temp_filename("$sp_drive/$share_name/$full_path");
                $file_infos = gh_get_file_infos($file);
                Log::debug("  Moving file copy...");
                $it_worked = gh_rename($file, $temp_path);
                if ($it_worked) {
                    gh_rename($temp_path, "$sp_drive/$share_name/$full_path");
                    gh_chperm("$sp_drive/$share_name/$full_path", $file_infos);

                    $pool_drives_avail_space[$sp_drive] -= $filesize;
                    $pool_drives_avail_space[$source_drive] += $filesize;
                } else {
                    Log::warn("    Failed file copy. Skipping.");
                    @unlink($temp_path);
                    continue;
                }

                // Update metafiles
                foreach (get_metafiles($share_name, $path, $filename, FALSE, TRUE, FALSE) as $existing_metafiles) {
                    foreach ($existing_metafiles as $key => $metafile) {
                        if ($metafile->path == $file) {
                            $metafile->path = "$sp_drive/$share_name/$full_path";
                            unset($existing_metafiles[$key]);
                            $metafile->state = 'OK';
                            if ($metafile->is_linked) {
                                // Re-create correct symlink
                                $landing_zone = $share_options[CONFIG_LANDING_ZONE];
                                if (is_link("$landing_zone/$full_path")) {
                                    Log::debug("  Updating symlink at $landing_zone/$full_path to point to $metafile->path");
                                    if (gh_recycle("$landing_zone/$full_path")) {
                                        @gh_symlink($metafile->path, "$landing_zone/$full_path");
                                        // Creating this symlink can fail if the parent dir was removed
                                    }
                                }
                            }
                            $existing_metafiles[$metafile->path] = $metafile;
                            save_metafiles($share_name, $path, $filename, $existing_metafiles);
                            break;
                        }
                    }
                }    
                $target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
                Log::debug("Balancing storage pool drive: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available, target: ". bytes_to_human($target_avail_space*1024, FALSE) .")");
            }
            Log::debug("Done balancing storage pool drive: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available)");
        }
        Log::debug("Done balancing share: $share_name");
    }
    
    if (@$skip_stickies) {
        // We skipped some stickies... Let's re-balance to move those, and continue balancing.
        $arr = debug_backtrace();
        if (count($arr) < 93) {
            Log::debug("Some shares with sticky files were skipped. Balancing will now re-start to continue moving those sticky files as needed, and further balance. Recursion level = " . count($arr));
            gh_balance();
        } else {
            Log::warn("Maximum number of consecutive balance reached. You'll need to re-execute --balance if you want to balance further.");
        }
    }
}

function is_share_sticky($share_name) {
    $sticky_files = Config::get(CONFIG_STICKY_FILES);
    if (!empty($sticky_files)) {
        foreach ($sticky_files as $share_dir => $stick_into) {
            if (string_starts_with($share_dir, $share_name)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

function compare_share_balance($a, $b) {
    if (is_share_sticky($a['name']) && !is_share_sticky($b['name'])) {
        return -1;
    }
    if (!is_share_sticky($a['name']) && is_share_sticky($b['name'])) {
        return 1;
    }
    if ($a[CONFIG_NUM_COPIES] != $b[CONFIG_NUM_COPIES]) {
        return $a[CONFIG_NUM_COPIES] > $b[CONFIG_NUM_COPIES] ? -1 : 1;
    }
    return strcasecmp($a['name'], $b['name']);
}

function sort_storage_drives_available_space() {
    $dfs = get_free_space_in_storage_pool_drives();
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (!isset($dfs[$sp_drive])) {
            continue;
        }
        $free_space = $dfs[$sp_drive]['free'];
        $minimum_free_space = Config::get(CONFIG_MIN_FREE_SPACE_POOL_DRIVE, $sp_drive);
        $available_space = (float) $free_space - $minimum_free_space;
        while (isset($sorted_target_drives["$available_space"])) {
            // In case some drives have the exact same amount of available_space, make sure we return all drives!
            $available_space++;
        }
        // On 32-bit systems, numeric array keys can't go over 2,147,483,648, so this would overflow on drives with more available space.
        // Using string keys will prevent overflows, and it will be cast into a number later, when we use it as such.
        $sorted_target_drives["$available_space"] = $sp_drive;
    }
    ksort($sorted_target_drives);
    return $sorted_target_drives;
}

function postpone_task($task_id, $complete='yes') {
    global $sleep_before_task;
    $query = "INSERT INTO tasks (action, share, full_path, additional_info, complete) SELECT action, share, full_path, additional_info, :complete FROM tasks WHERE id = :task_id";
    $params = array(
        'complete' => $complete,
        'task_id' => $task_id
    );
    DB::insert($query, $params);
    $sleep_before_task[] = DB::lastInsertedId();
}

function process_config() {
    while (!ConfigHelper::parse()) {
        // Invalid config file; either it's missing storage_pool_drive, or it contains a share that isn't in smb.conf
        if (SystemHelper::is_amahi() && Log::actionIs(ACTION_DAEMON)) {
            // If running on Amahi, loop until the config works.
            // User might configure Greyhole later, and they don't want to show Greyhole 'offline' until then. Those users are easy to confuse! ;)
            sleep(600); // 10 minutes
        } else {
            // Otherwise, die.
            Log::critical("Config file parsing failed. Exiting.");
        }
    }
    // Config is OK; go on!
}

function gh_wild_mb_strpos($haystack, $needle) { 
    $is_wild = string_contains($needle, "*");
    if (!$is_wild) {
        return mb_strpos($haystack, $needle);
    }
    if (str_replace('*', '', $needle) == $haystack) {
        return FALSE;
    }
    $needles = explode("*", $needle);
    if ($needle[0] == '*') {
        $first_index = 0;
    }
    foreach ($needles as $needle_part) {
        if ($needle_part == '') {
            continue;
        }
        $needle_index = mb_strpos($haystack, $needle_part);
        if (!isset($first_index)) {
            $first_index = $needle_index;
        }
        if ($needle_index === FALSE) {
            return FALSE;
        } else {
            $found = TRUE;
            $haystack = mb_substr($haystack, $needle_index + mb_strlen($needle_part));
        }
    }
    if ($found) {
        return $first_index;
    }
    return FALSE;
}

function str_replace_first($search, $replace, $subject) {
    $firstChar = mb_strpos($subject, $search);
    if ($firstChar !== FALSE) {
        $beforeStr = mb_substr($subject, 0, $firstChar);
        $afterStr = mb_substr($subject, $firstChar + mb_strlen($search));
        return $beforeStr . $replace . $afterStr;
    } else {
        return $subject;
    }
}

function set_metastore_backup($try_restore=TRUE) {
    $num_metastore_backups_needed = 2;
    if (count(Config::storagePoolDrives()) < 2) {
        Config::set(CONFIG_METASTORE_BACKUPS, array());
        return;
    }

    Log::debug("Loading metadata store backup directories...");
    $metastore_backup_drives = Config::get(CONFIG_METASTORE_BACKUPS);
    if (empty($metastore_backup_drives)) {
        // In the DB ?
        $metastore_backup_drives = Settings::get('metastore_backup_directory', TRUE);
        if ($metastore_backup_drives) {
            Log::debug("  Found " . count($metastore_backup_drives) . " directories in the settings table.");
        } else if ($try_restore) {
            // Try to load a backup from the data drive, if we can find one.
            if (Settings::restore()) {
                set_metastore_backup(FALSE);
                return;
            }
        }
    }

    // Verify the drives, if any
    if (empty($metastore_backup_drives)) {
        $metastore_backup_drives = array();
    } else {
        foreach ($metastore_backup_drives as $key => $metastore_backup_drive) {
            if (!StoragePool::is_pool_drive(str_replace('/.gh_metastore_backup', '', $metastore_backup_drive))) {
                // Directory is now invalid; stop using it.
                Log::debug("Removing $metastore_backup_drive from available 'metastore_backup_directories' - this directory isn't a Greyhole storage pool drive (anymore?)");
                unset($metastore_backup_drives[$key]);
            } else if (!is_dir($metastore_backup_drive)) {
                // Directory is invalid, but needs to be created (was rm'ed?)
                mkdir($metastore_backup_drive);
            }
        }
    }
    
    if (empty($metastore_backup_drives) || count($metastore_backup_drives) < $num_metastore_backups_needed) {
        Log::debug("  Missing some drives. Need $num_metastore_backups_needed, currently have " . count($metastore_backup_drives) . ". Will select more...");
        $metastore_backup_drives_hash = array();
        if (count($metastore_backup_drives) > 0) {
            $metastore_backup_drives_hash[array_shift($metastore_backup_drives)] = TRUE;
        }

        while (count($metastore_backup_drives_hash) < $num_metastore_backups_needed) {
            // Let's pick new one
            $metastore_backup_drive = ConfigHelper::randomStoragePoolDrive() . '/.gh_metastore_backup';
            $metastore_backup_drives_hash[$metastore_backup_drive] = TRUE;
            if (!is_dir($metastore_backup_drive)) {
                mkdir($metastore_backup_drive);
            }
            Log::debug("    Randomly picked $metastore_backup_drive");
        }
        $metastore_backup_drives = array_keys($metastore_backup_drives_hash);

        // Got 2 drives now; save them in the DB
        Settings::set('metastore_backup_directory', $metastore_backup_drives);
    }

    Config::set(CONFIG_METASTORE_BACKUPS, $metastore_backup_drives);
}

function create_trash_share_symlink($filepath_in_trash, $trash_path) {
    $trash_share = SharesConfig::getConfigForShare(CONFIG_TRASH_SHARE);
    if ($trash_share) {
        $filepath_in_trash = clean_dir($filepath_in_trash);
        $filepath_in_trash_share = str_replace($trash_path, $trash_share[CONFIG_LANDING_ZONE], $filepath_in_trash);
        if (file_exists($filepath_in_trash_share)) {
            $new_filepath = $filepath_in_trash_share;
            $i = 1;
            while (file_exists($new_filepath)) {
                if (@readlink($new_filepath) == $filepath_in_trash) {
                    // There's already a symlink to that file in the trash share; let's not make a second one!
                    return;
                }
                $new_filepath = "$filepath_in_trash_share copy $i";
                $i++;
            }
            $filepath_in_trash_share = $new_filepath;
            list($original_path, $filename) = explode_full_path($filepath_in_trash_share);
        } else {
            list($original_path, $filename) = explode_full_path($filepath_in_trash);
            list($path, $filename) = explode_full_path($filepath_in_trash_share);

            $dir_infos = (object) array(
                'fileowner' => (int) gh_fileowner($original_path),
                'filegroup' => (int) gh_filegroup($original_path),
                'fileperms' => (int) base_convert("0777", 8, 10)
            );
            gh_mkdir($path, $dir_infos);
        }
        if (@gh_symlink($filepath_in_trash, $filepath_in_trash_share)) {
            Log::debug("  Created symlink to deleted file in {$trash_share['name']} share ($filename).");
        } else {
            Log::warn("  Warning! Couldn't create symlink to deleted file in {$trash_share['name']} share ($filename).");
        }
    }
}

function get_conf_md5() {
    exec("grep -ie 'num_copies\|storage_pool_directory\|storage_pool_drive\|sticky_files' " . escapeshellarg(ConfigHelper::$config_file) . " | grep -v '^#'", $content);
    exec("grep -ie 'path\|vfs objects' " . escapeshellarg(ConfigHelper::$smb_config_file) . " | grep -v '^#'", $content);
    return md5(implode("\n", $content));
}

function how_long_ago($past_time) {
    $ago = '';
    $s = time() - $past_time;
    $m = floor($s / 60);
    if ($m > 0) {
        $s -= $m * 60;
        $h = floor($m / 60);
        if ($h > 0) {
            $ago = $h . "h ";
            $m -= $h * 60;
        }
        $ago = $ago . $m . "m ";
    }
    $ago = $ago . $s . "s";
    if ($ago == '0s') {
        return 'just now';
    }
    return "$ago ago";
}

function get_copy_cmd($source, $destination) {
    $copy_method = Config::get('copy_method');
    if ($copy_method === 'rsync') {
        return "rsync -t " . escapeshellarg($source) . " " . escapeshellarg($destination);
    } elseif (substr($copy_method, 0, 6) === "custom" && strpos($copy_method, ":") !== FALSE) {
        return substr($copy_method, strpos($copy_method, ":") + 1) . " " . escapeshellarg($source) . " " . escapeshellarg($destination);
    } else {
        return "cp -p " . escapeshellarg($source) . " " . escapeshellarg($destination);
    }
}

function task_has_option($task, $option) {
    return string_contains($task->additional_info, $option);
}

function spawn_thread($action, $arguments) {
    // Don't spawn duplicate threads
    $num_worker_thread = (int) exec('ps ax | grep "/usr/bin/greyhole --' . $action . '" | grep "drive='. implode('" | grep "drive=', $arguments) . '" | grep -v grep | wc -l');
    if ($num_worker_thread > 0) {
        Log::debug("Won't span a duplicate thread; 'greyhole --$action --drive=$arguments[0]' is already running");
        return 1;
    }

    $cmd = "/usr/bin/greyhole --$action --drive=" . implode(' --drive=', array_map('escapeshellarg', $arguments));
    exec("$cmd 1>/var/run/greyhole_thread.pid 2>&1 &");
    usleep(100000); // 1/10s
    return (int) file_get_contents('/var/run/greyhole_thread.pid');
}

function gh_check_md5($task) {
    $share_options = SharesConfig::getConfigForShare($task->share);

    $query = "SELECT complete, COUNT(*) AS num, GROUP_CONCAT(id) AS ids FROM tasks WHERE action = 'md5' AND share = :share AND full_path = :full_path GROUP BY complete ORDER BY complete ASC";
    $params = array(
        'share' => $task->share,
        'full_path' => $task->full_path
    );
    $rows = DB::getAll($query, $params);
    $complete_tasks = array_shift($rows); // ORDER BY complete ASC in the above query will always return complete='yes' first
    if (empty($complete_tasks)) {
        Log::debug("  Already checked this file. Skipping.");
        return;
    }
    $incomplete_tasks = @array_shift($rows);
    if (empty($incomplete_tasks)) {
        $incomplete_tasks = array();
    }
    if (count($incomplete_tasks) > 0) {
        // We don't have all of them yet. Let's post-pone this until we do.
        $query = "INSERT INTO tasks (action, share, full_path, additional_info, complete) SELECT action, share, full_path, additional_info, complete FROM tasks WHERE id = :task_id";
        DB::insert($query, array('task_id' => $task->id));

        // If there's no worker thread alive, spawn all of them. The idle ones will just die.
        $num_worker_threads = (int) trim(exec("ps x | grep '/usr/bin/greyhole --md5-worker' | grep -v grep | wc -l"));
        if ($num_worker_threads == 0) {
            Log::debug("  Will spawn new worker threads to work on this.");
            foreach (Config::storagePoolDrives() as $sp_drive) {
                spawn_thread('md5-worker', array($sp_drive));
            }
        } else {
            // Give the worker thread some time to catch up
            Log::debug("  Will wait some to allow for MD5 worker threads to complete.");
            sleep(5);
        }
        return;
    }
    
    // We have all of them; let's check the MD5 checksums
    Log::debug("Checking MD5 checksums for " . clean_dir("$task->share/$task->full_path"));
    $result_tasks = DB::getAll("SELECT * FROM tasks WHERE id IN ($complete_tasks->ids)");
    $md5s = array();
    foreach ($result_tasks as $t) {
        if (preg_match('/^(.+)=([0-9a-f]{32})$/', $t->additional_info, $regs)) {
            $md5s[$regs[2]][] = clean_dir($regs[1]);
        } else {
            $md5s['unreadable files'][] = clean_dir($t->additional_info);
        }
    }
    if (count($md5s) == 1) {
        $md5s = array_keys($md5s);
        $md5 = reset($md5s);
        
        if ($md5 == 'unreadable files') {
            // Oopsy!
            $logs = array(
                "  The following file is unreadable: " . clean_dir($t->additional_info),
                "  The underlying filesystem probably contains errors. You should unmount that partition, and check it using e2fsck -cfp"
            );
        } else {
            Log::debug("  All copies have the same MD5 checksum: $md5");
        }
    }
    else if (count($md5s) > 1) {
        // Oopsy!
        $logs = array("Mismatch in file copies checksums:");
        foreach ($md5s as $md5 => $file_copies) {
            $latest_file_copy = $file_copies[count($file_copies)-1];
            $file_copies = array_unique($file_copies);
            sort($file_copies);
            $files = implode(', ', $file_copies);

            // Automatically fix this if:
            // - there's only 2 different MD5s for all file copies (i.e. one for all other files copies, and one for this file copy)
            // - the current MD5 is only for one file copy (we assume this copy is in error, not the others)
            // - that file copy isn't used as the share symlink target
            $original_file_path = clean_dir(readlink(get_share_landing_zone($task->share) . "/" . $task->full_path));
            if (count($md5s) == 2 && count($file_copies) == 1 && $latest_file_copy != $original_file_path) {
                $original_md5 = 'Unknown';
                foreach ($md5s as $this_md5 => $file_copies) {
                    foreach ($file_copies as $file_copy) {
                        if ($file_copy == $original_file_path) {
                            $original_md5 = $this_md5;
                            break;
                        }
                    }
                }

                Log::warn("  A file copy with a different checksum than the original was found: $latest_file_copy = $md5. Original: $original_file_path = $original_md5");
                Log::warn("  This copy will be deleted, and replaced with a new copy from $original_file_path");
                gh_recycle($latest_file_copy);

                $metafiles = array();
                list($path, $filename) = explode_full_path($task->full_path);
                foreach (get_metafiles($task->share, $path, $filename, TRUE, TRUE, FALSE) as $existing_metafiles) {
                    foreach ($existing_metafiles as $key => $metafile) {
                        $metafiles[$key] = $metafile;
                    }
                }
                create_copies_from_metafiles($metafiles, $task->share, $task->full_path, $original_file_path, TRUE);

                Log::debug("  Calculating MD5 for new file copy at $latest_file_copy ...");
                $md5 = md5_file($latest_file_copy);
                Log::debug("    MD5 = $md5");
                if ($md5 == $original_md5) {
                    Log::debug("  All copies have the same MD5 checksum: $md5");
                    delete_tasks($complete_tasks->ids);
                    return;
                }
            }

            $logs[] = "  [$md5] => $files";
        }
        $logs[] = "Some of the above files appear to be unreadable.";
        $logs[] = "The underlying filesystem(s) probably contains errors. You should unmount this/those partition(s), and check it/them using: fsck -cfp /dev/[...]";
        $logs[] = "You should manually check which file copy is invalid, and delete it. Re-create a valid copy with:";
        $logs[] = "  sudo greyhole --fsck --checksums --dir " . escapeshellarg(dirname(clean_dir($share_options[CONFIG_LANDING_ZONE] . "/$task->full_path")));
    }
    
    if (isset($logs)) {
        // Write to greyhole.log
        foreach ($logs as $log) {
            Log::error($log);
        }

        // Write in fsck_checksums.log too
        $flog = fopen(FSCKLogFile::PATH . '/fsck_checksums.log', 'a');
        if (!$flog) {
            Log::critical("Couldn't open log file: " . FSCKLogFile::PATH . "/fsck_checksums.log");
        }
        fwrite($flog, $date = date("M d H:i:s") . ' ' . implode("\n", $logs) . "\n\n");
        fclose($flog);

        unset($logs);
    }
    
    delete_tasks($complete_tasks->ids);
}

function delete_tasks($task_ids) {
    DB::execute("DELETE FROM tasks WHERE id IN ($task_ids)");
}

function check_md5_workers() {
    $query = "SELECT * from tasks WHERE action = 'md5' AND complete = 'no' LIMIT 1";
    $row = DB::getFirst($query);
    if ($row) {
        $num_worker_threads = (int) trim(exec("ps x | grep '/usr/bin/greyhole --md5-worker' | grep -v grep | wc -l"));
        if ($num_worker_threads == 0) {
            Log::debug("Will spawn new worker threads to work on incomplete checksums calculations.");
            foreach (Config::storagePoolDrives() as $sp_drive) {
                if (StoragePool::is_pool_drive($sp_drive)) {
                    spawn_thread('md5-worker', array($sp_drive));
                }
            }
        }
    }
}

function get_count_md5() {
    return (int) DB::getFirstValue("SELECT COUNT(*) FROM tasks WHERE action = 'md5'");
}

function set_fsck_options($task) {
    global $options;
    $options['all-fsck-options'] = $task->additional_info;
    $options['find-orphans'] = task_has_option($task, OPTION_ORPHANED);
    $options['verify-checksums'] = task_has_option($task, OPTION_CHECKSUMS);
    $options['del-orphaned-metadata'] = task_has_option($task, OPTION_DEL_ORPHANED_METADATA);
}

function remove_drive_definition($going_drive) {
    $drives_definitions = Settings::get('sp_drives_definitions', TRUE);
    if (!$drives_definitions) {
        $drives_definitions = MigrationHelper::convertStoragePoolDrivesTagFiles();
    }
    unset($drives_definitions[$going_drive]);
    Settings::set('sp_drives_definitions', $drives_definitions);
}

function get_file_inodes($share, $file_path, $filename, &$file_metafiles, $one_is_enough=FALSE) {
    $file_copies_inodes = array();
    
    foreach (Config::storagePoolDrives() as $sp_drive) {
        $clean_full_path = clean_dir("$sp_drive/$share/$file_path/$filename");
        if (is_link($clean_full_path)) {
            continue;
        }
        $inode_number = @gh_fileinode($clean_full_path);
        if ($inode_number !== FALSE) {
            if (is_dir($clean_full_path)) {
                Log::warn("Warning! Found a directory that should be a file! Will try to remove it, if it's empty.");
                @rmdir($clean_full_path);
                continue;
            }

            Log::debug("Found $clean_full_path");

            if (!StoragePool::is_pool_drive($sp_drive)) {
                $state = 'Gone';
                if (!$one_is_enough) {
                    Log::info("  Drive $sp_drive is not part of the Greyhole storage pool anymore. The above file will not be counted as a valid file copy, but can be used to create a new valid copy.");
                }
            } else {
                $state = 'OK';
                $file_copies_inodes[$inode_number] = $clean_full_path;
                if ($one_is_enough) {
                    return $file_copies_inodes;
                }
            }
            if (is_string($file_metafiles)) {
                Log::critical("Fatal error! \$file_metafiles is now a string: '$file_metafiles'.");
            }
            $file_metafiles[$clean_full_path] = (object) array('path' => $clean_full_path, 'is_linked' => FALSE, 'state' => $state);
            
            // Temp files leftovers of stopped Greyhole executions
            $temp_filename = get_temp_filename($clean_full_path);
            if (file_exists($temp_filename) && gh_is_file($temp_filename)) {
                Log::info("  Found temporary file $temp_filename ... deleting.");
                $fsck_report['temp_files'][] = $temp_filename;
                unlink($temp_filename);
            }
        }
    }

    return $file_copies_inodes;
}

function normalize_utf8_characters($string) {
    // Requires intl PHP extension (php-intl)
    return normalizer_normalize($string);
}
?>
